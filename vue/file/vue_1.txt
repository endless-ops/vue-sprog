1. 安装 cnpm
    npm install -g cnpm --registry=https://registry.npm.taobao.org

2. 安装 vue.js
    cnpm install -g vue
3. 安装 vue devtools

    下载 vue devtools
        https://github.com.vuejs/vue-devtools.git

    进入 vue-devtools目录下，安装构建工具所需的依赖
        cnpm install
    构建工具
        npm run build


4. vue 中的 data
    1. 在 vue 实例中 data 是一个对象，也可以是一个 函数
    2. 在 组件中，data 只能是一个函数，且必须返回一个对象


5. 什么是Vue
    Vue.js 是一款MVVM模式实现的轻量级，渐进式的JavaScript框架
    vue的核心库只关注视图层，并且提供尽可能简单的API以实现数据绑定、组件复用等机制，
    vue完全支持SPA设计和组合其他Vue生态库的系统


6. 数据响应式的原理
    Vue最重要的概念是响应式数据。一方面指元数据与衍生数据之间的响应，通过数据链来实现；另一方面指的是数据与视图之间的绑定

7. 函数式编程
    是一种结构化编程方式，力求将运算过程写成一系列嵌套的函数调用
    函数式编程认为函数可以赋值给其他变量、用作另一个函数的参数或者作为函数返回值来使用
    函数式编程的核心是根据元数据生成新的衍生数据，提供唯一确定的输入，函数将返回唯一确定的输出，且并不会修改原有变量的值。

8. Vue中的数据链
    Vue实例提供了computed计算属性，以供生成衍生数据对象。计算属性以函数形式声明，但是不接收参数，也只能以属性的方式调用。
    计算属性的this指向Vue实例，所以它可以获取实例上的所有已挂载的可见属性。

    对象属性配置表
    名称                                      默认值                         说明
    configurable                              false                         标识属性配置是否可以更改和该属性能否从对象中删除
    enumerable                                false                         标识属性是否可被枚举
    writable                                  false                         标识属性是否可通过赋值运算符修改，不与set共存
    value                                     undefined                     属性值，可为任意JS数据类型，不与set共存
    set                                       undefined                     函数类型，属性被赋值时调用
    get                                       undefined                     函数类型，返回值将作为属性值

    有关defineProperty的代码

    <span id="harry" style="line-height:32px"></span>
    <br>
    <input id="trigger" type="text" />
    <script>
        let harry = document.getElementById("harry");
        let trigger = document.getElementById("trigger");

        let key = "profile";
        let store = {};
        let obj = {
            profile: ''
        }

        Object.defineProperty(
            obj,
            key,
            {
                set (value) {
                    harry.innerText = value;
                    store[key] = value;
                },

                get () {
                    return store[key];
                }

            }
        )

        trigger.addEventListener('keyup',function {
            obj[key] = this.value;
            console.log(obj[key]);
        })
    </script>

    上述代码中，在对象属性的setter函数中修改文本节点的值，所以当obj.profile被重新赋值时，节点视图也会同步更新；然后对输入框添加监听事件当用户事件触发时，输入值将被赋于 obj.profile。
    以此方式，实现了数据与视图之间的 “双向绑定”。这也是Vue数据与视图绑定的实现原理.

9. 插值绑定
    9.1 文本插值
        只要用 双大括号（Mustache语法）将要绑定的变量、值、表达式括住就可以实现，vue将会获取计算后的值，并以文本的形式将其展示出来。
        实例代码：
            <!DOCTYPE html>
            <html lang="en">
            <head>
                <meta charset="UTF-8">
                <title>文本插值-插值绑定</title>
                <style>
                    .profile {
                        display: inline-block;
                        width: 300px;
                    }
                </style>
            </head>
            <body>
                <div id="app" style="margin-left: 300px">
                    <h2>文本插值</h2>
                    <p><label class="profile">变量：</label> {{num}}</p>
                    <p><label class="profile">表达式：</label> {{5 + 10}}</p>
                    <p><label class="profile">三目运算符：</label> {{true ? 15 : 10}}</p>
                    <p><label class="profile">函数：</label> {{getNum()}}</p>
                    <p><label class="profile">匿名函数：</label> {{ (() => 5 + 10)() }}</p>
                    <p><label class="profile">对象：</label> {{{num : 15} }}</p>
                    <p><label class="profile">函数对象：</label> {{ getNum }}</p>
                    <p><label class="profile">Html代码（表达式）：</label> {{ '<span>15</span>' }}</p>
                    <p><label class="profile">Html代码（变量）：</label> {{ html }}</p>
                </div>

                <script src="https://cdn.jsdelivr.net/npm/vue@2.5.16/dist/vue.min.js"></script>
                <script type="text/javascript">
                    let vm = new Vue({
                        el: '#app',
                        data () {
                            return {
                                num : 15,
                                html : '<span>15</span>'
                            }
                        },
                        methods : {
                            getNum() {
                                return this.num
                            }
                        }
                    })
                </script>
            </body>
            </html>

        关于 html（表达式）和 html（变量）的差异，对于前者来说，Vue优先解释了 DOM 节点 span ,并隔离了 {{ 和 }} ，所以插值语法并未生效， {{ 和 }} 还被当作了 p 节点的文本内容
    9.2 HTML插值
        HTML插值可以动态渲染DOM节点，常用于处理开发者无可预知和难以控制的DOM结构，如渲染用户随意书写的文档结构等。
        实例代码：` 是 ESC按键下的 一个符号
            <!DOCTYPE html>
            <html lang="en">
            <head>
                <meta charset="UTF-8">
                <title>HTML插值-插值绑定</title>
                <style>
                    .align-center {
                        text-align: center;
                    }
                </style>
            </head>
            <body>
                <div id="app" style="width: 800px;margin: 0 auto;">
                    <div>{{blog}}</div>
                    <hr>
                    <div v-html="blog"></div>
                </div>
                <script src="https://cdn.jsdelivr.net/npm/vue@2.5.16/dist/vue.min.js"></script>
                <script type="text/javascript">
                    let vm = new Vue({
                        el: '#app',
                        data () {
                            return {
                                blog : `<h2 class="align-center">一对“兄弟”</h2>
                                        <div class="align-center">
                                            <img src="http://img.hb.aicdn.com/76c310ae6a6c6166343a23821078d379367f003e2088d-xWozMi_fw658"/>

                                        </div>
                                        <p>你看他们多像一对兄弟啊，虽然是一对呆呆兔和一只傻傻猫蹲在了一起，但谁又能说他们不是兄弟呢？</p>`
                            }
                        }
                    })
                </script>
            </body>
            </html>

        文本插值中的代码被解释为节点的文本内容，而HTML插值中的代码则被解释为视图节点。实际上，HTML插值为文本插值的补充和拓展，Vue可以解析被绑定的内容为DOM节点，
        从而实现动态渲染视图的效果。不过Vue本身就支持模板，开发者在使用HTML插值的时候，应秉承以下原则：
            尽量多地使用Vue自身的模板，减少对HTML插值的使用
            只对可信内容使用HTML插值
            决不相信用户输入的数据


10. 属性绑定
    10.1 指令
        10.1.1 v-bind：DOM节点的属性基本都可以用 v-bind 进行绑定
            代码如下：
                <style>
                    .italic {font-style: italic;}
                </style>
                <div id="app" style="margin-left: 300px">
                    <p v-bind:class="className" v-bind:title="title">危险勿触</div>
                    <button v-bind:disabled="10 + 10 === 20" > 点击有奖 </button>
                    <input v-bind:type="'text'" v-bind::placeholder="true ? '输入': '请录入'"/>
                </div>

                <script src="https://cdn.jsdelivr.net/npm/vue@2.5.16/dist/vue.min.js"></script>
                <script>
                    let vm = new Vue({
                        el:'#app',
                        data () {
                            return {
                                className : 'italic',
                                title : '危险勿触'
                            }
                        }
                    })
                </script>
            当然，v-bind 也可以省略不写，代码如下：
                <div id="app" style="margin-left: 300px">
                    <p :class="className" :title="title">危险勿触</div>
                    <button :disabled="10 + 10 === 20" > 点击有奖 </button>
                    <input :type="'text'" :placeholder="true ? '输入': '请录入'"/>
                </div>
            属性也可以是绑定变量、表达式、执行函数等内容，不过最终的结果都应该满足属性自身的约束。

    10.2 类名和样式绑定
        10.2.1 类名绑定
            由于类名 class 和 样式 style 在节点属性中是两个奇怪的存在（虽然可以接收的类型都是字符串，但类名实际上是有数组拼接组成，而样式则是有对象键值对拼接而成的），
            所以Vue在绑定类名和样式时也采用不一样的机制。

            可以通过 字符串、数组和对象 三种方式为节点 动态绑定类名属性，代码如下：
                <style>
                    .color-gray {color:gray;}
                    .size-18 {font-size:18px;}
                    .style-italic {font-style:italic}

                </style>
                <div id="app">
                    <p class="color-gray size-18 style-italic">《Vue2.0 从入门到实战》，用心良苦，伴你成长</p>
                    <p :class="classStr">《Vue2.0 从入门到实战》，用心良苦，伴你成长</p>
                    <p :class="classArr">《Vue2.0 从入门到实战》，用心良苦，伴你成长</p>
                    <p :class="classObj1">《Vue2.0 从入门到实战》，用心良苦，伴你成长</p>
                    <p :class="classObj2">《Vue2.0 从入门到实战》，用心良苦，伴你成长</p>
                </div>
                <script src="https://cdn.jsdelivr.net/npm/vue@2.5.16/dist/vue.min.js"></script>
                <script>
                    let vm = new Vue({
                        el : '#app',
                        data () {
                            return {
                                classStr : 'color-gray size-18 style-italic',
                                classArr : ['color-gray','size-18','style-italic'],
                                classObj1: {'class-gray':true,'size-18':true,'style-italic':true}, // 对象，绑定类名
                                classObj2: {'class-gray':0,'size-18':'','style-italic':false}, // 对象，未绑定类名
                            }
                        }
                    })

                </script>

                在使用对象绑定类名时，应将类名作为对象键名，当键值为真时，类名将被绑定到节点上。
                真假知识点：
                    当变量值为undefined、null、0、空字符串时，判定为假，
                    除一般值外，[]、{}、-1、-0.1 也会被判定为真

        10.2.2 样式绑定
            绑定样式的方式和类名相似，但是样式是以键值对的形式，所以不能像类名一样使用数组进行绑定，代码如下：
                <div id="app">
                    <p style="color:gray; font-size:18px; font-style:italic;">《Vue2.0 从入门到实战》，用心良苦，伴你成长</p>
                    <p :style="classStr">《Vue2.0 从入门到实战》，用心良苦，伴你成长</p>
                    <p :style="classObj1">《Vue2.0 从入门到实战》，用心良苦，伴你成长</p>
                    <p :style="classObj2">《Vue2.0 从入门到实战》，用心良苦，伴你成长</p>
                </div>
                <script src="https://cdn.jsdelivr.net/npm/vue@2.5.16/dist/vue.min.js"></script>
                <script>
                    let vm = new Vue({
                        el : '#app',
                        data () {
                            return {
                                styleStr : 'color:gray; font-size:18px; font-style:italic;',
                                classObj1: {color: -1 ? 'gray' : 'black'; font-size:'18px'; font-style:'italic';}, // 对象，绑定类名
                                classObj2: {color: 0 ? 'gray' : ''; font-size:'' ? '18px' : ''; font-style:null ? 'italic' : '';}, // 对象，未绑定类名
                            }
                        }
                    })
                </script>



11. 事件绑定
    事件系统是前端开发中非常重要的内容，Vue也对其进行了封装和拓展，使之变得更加简单易用。
    11.1 指令
        v-on
            ：Vue使用 v-on 指令监听DOM事件，开发这可以将事件代码通过 v-on 指令绑定到 DOM 节点上，基本使用方法如下：

            <div id="app">
                <button v-on:click="logInfo()">打印消息（default：Hello World）</button>
                <br>
                <button v-on:click="logInfo('Self Message')">打印消息（default：Hello World）</button>
                <br>
                <button v-on:click="console.log('A Vue App')">打印消息（default：Hello World）</button>
            </div>
            <script src="https://cdn.jsdelivr.net/npm/vue@2.5.16/dist/vue.min.js"></script>
            <script>
                let vm = new Vue({
                    el: '#app',
                    methods: {
                        logInfo(msg) {
                            console.log(msg || 'Hello World')
                        }
                    }
                })
            </script>

        Vue 也为 v-on 提供了一种简写形式 @ ，代码如下：
            <button @click="logInfo()">打印消息（default：Hello World）</button>
        有时候，我们在处理事件时，也会用到事件对象本身，那么应该怎样获取事件对象本身呢？
        两种方式,代码如下：
            <div id="app">
                <!-- 1. 在事件函数不必传参数时，可以这样写，注意：不能带() -->
                <input type="text" @keyup="handleKeyUp"/>
                <!-- 2. 手动传入 $event对象 -->
                <input type="text" @keyup="handleKeyUp($event)"/>
            </div>
            <script src="https://cdn.jsdelivr.net/npm/vue@2.5.16/dist/vue.min.js"></script>
            <script>
                let vm = new Vue({
                    el: '#app',
                    methods: {
                        handleKeyUp(event) {
                            console.log(event.key,event);
                        }
                    }
                })
            </script>

    11.2 常见修饰符
        JS事件代码开发 event.preventDefault() 阻止节点默认行为
        event.stopPropagation 阻止事件冒泡，
        vue 将其 封装成简短医用的事件修饰符，可以后缀与事件名称之后

        常见的事件修饰符：

        名称          可用版本            可用事件                    说明
        .stop         所有                任意                      当事件触发时，阻止事件冒泡
        .prevent      所有                任意                      当事件触发时，阻止元素默认行为
        .capture      所有                任意                      当事件触发时，阻止事件捕获
        .self         所有                任意                      限制事件仅作用于节点自身
        .once         2.1.4以上           任意                      事件被触发一次后即解除监听
        .passive      2.3.0以上           滚动                      移动端，限制事件永不调用preventDefault()方法


        .prevent 修饰符在表单提交时的表现，先来看不使用修饰符时的情况，代码如下：
            <div id="app">
                <form @submit="handleSubmit">
                    <h2>不使用修饰符时</h2>
                    <button type="submit">提交</button>
                </form>
            </div>
            <script src="https://cdn.jsdelivr.net/npm/vue@2.5.16/dist/vue.min.js"></script>
            <script>
                let vm = new Vue({
                    el: '#app',
                    data() {
                        return {
                            counter:0
                        }
                    },
                    methods: {
                        handleSubmit() {
                            console.log(`submit $(++this.counter) times`);
                        }
                    }
                })
            </script>

        为事件添加 .prevent 修饰符，代码如下：
            <form @submit.prevent="handleSubmit">
                <h2>使用.prevent 修饰符</h2>
                <button type="submit">提交</button>
            </form>

        当事件后缀多个修饰符时，要注意修饰符的排列顺序，相应的代码会根据排列顺序依次产生。
    11.3 按键修饰符
        对于键盘事件，vue允许将按键值作为修饰符来来使用，如监听回车键

        常用按键修饰符别名
        别名修饰符                       键值修饰符                       对应按键
        .delete                         .8/.46                          辉格 / 删处
        .tab                            .9                              制表
        .enter                          .13                             回车
        .esc                            .27                             退出
        .space                          .32                             空格
        .left                           .37                             左
        .up                             .38                             上
        .right                          .39                             右
        .down                           .40                             下

        鼠标按键修饰符
        修饰符                     可用版本                        对应按键
        .left                     2.2.0以上                       左键
        .right                    2.2.0以上                       右键
        .middle                   2.2.0以上                       中键

    11.4 组合修饰符
        系统按钮修饰符

        修饰符                     可用版本                            对应按键
        .ctrl                     2.1.0以上                           Ctrl键
        .alt                      2.1.0以上                           Alt键
        .shift                    2.1.0以上                           Shift键
        .meta                     2.1.0以上                           meta键 （windows系统键盘上 win 键）

        <div id="app">
            <h1 @click.ctrl="logWithCtrl" @click="logSingle">没有ctrl别来点我</h1>
        </div>
        <script src="https://cdn.jsdelivr.net/npm/vue@2.5.16/dist/vue.min.js"></script>
        <script>
            let vm = new Vue({
                el: '#app',
                methods: {
                    logWithCtrl (event) {
                        console.log("-------------分割线-------------")
                        console.log("$event.ctrlKey:" ,event.ctrlKey)
                        console.log('按住，是的，按住 Ctrl')
                    },

                    logSingle(event) {
                        if (!event.ctrlKey) {
                            console.log("-------------分割线-------------")
                             console.log("$event.ctrlKey:" ,event.ctrlKey)
                             console.log('点我干啥，单身汪')
                        }else {
                            console.log('不错，进步很快呀!')
                        }
                    }
                }
            })
        </script>

12. 双向绑定
    指令 v-model：它负责监听用户的输入事件以更新数据

        v-model 在内部使用不同的属性为不同的输入元素并抛出不同的事件：
           1. text 和 textarea 使用 value 属性和 input 事件；
           2. checkbox 和 radio 使用 checked 属性和 change 事件；
           3. select 字段将 value 作为 prop 并将 change 作为事件。


        官方有说到，v-model的原理其实是背后有两个操作：

            1. v-bind绑定value属性的值；

            2. v-on绑定input事件监听到函数中，函数会获取最新的值赋值到绑定的属性中；


        v-model 和 v-show 时vue核心功能中内置的、开发者不可自定义的指令
        可以使用v-model为可输入元素创建双向数据绑定，它会根据元素类型自动选取正确的方法来更新元素
        代码实例如下：
            <!DOCTYPE html>
            <html lang="en">
            <head>
                <meta charset="UTF-8">
                <title>HTML插值-插值绑定</title>
                <style>
                    .align-center {
                        text-align: center;
                    }
                </style>
            </head>
            <body>
            <div id="app" style="width: 800px;margin: 0 auto;">
                <h3>单行文本框</h3>
                <input type="text" v-model="singleText" style="width: 240px;"/>
                <p>{{ singleText }}</p>
                <h3>多行文本框</h3>
                <textarea v-model="multiText" style="width: 240px;"></textarea>
                <pre>{{ multiText }}</pre>

                <h3>单选框</h3>
                <!--
                    由于点击被选中的单选项无法取消其被选中的状态，所以实战中一般没有使用单个但选项的场景。
                    这里，设置 v-model 共用同一个变量 可实现 RadioGroup 的效果
                -->
                <input type="radio" id="ra" value="杨玉环" v-model="radioValue">
                <label for="ra">A.杨玉环</label>
                <input type="radio" id="rb" value="赵飞燕" v-model="radioValue">
                <label for="rb">B.赵飞燕</label>
                <p>{{ radioValue }}</p>

                <h3>单个复选框</h3>
                <!--
                    单个复选框被用于true 和 false 的切换
                -->
                <input id="c" type="checkbox" v-model="toggleValue"/>
                <label for="c">天生丽质</label>
                <p>{{ toggleValue }}</p>

                <h3>多个复选框</h3>
                <!--
                    v-model 接收数组类型变量
                -->
                <input id="ca" type="checkbox" value="漂亮" v-model="checkedValues"/>
                <label for="ca">A.回眸一笑百媚生</label>
                <input id="cb" type="checkbox" value="瘦弱" v-model="checkedValues"/>
                <label for="cb">B.体轻能为掌上舞</label>
                <input id="cc" type="checkbox" value="得宠" v-model="checkedValues"/>
                <label for="cc">C.三千宠爱在一身</label>
                <p>{{ checkedValues.join(',') }}</p>
            </div>
            <script src="https://cdn.jsdelivr.net/npm/vue@2.5.16/dist/vue.min.js"></script>
            <script type="text/javascript">
                let vm = new Vue({
                    el: '#app',
                    data() {
                        return {
                            singleText: '',
                            multiText: '',
                            radioValue: '',
                            toggleValue: '',
                            checkedValues: []
                        }
                    }
                })
            </script>
            </body>
            </html>

        下拉框也可以使用v-model进行双向绑定。代码如下：
            <!DOCTYPE html>
            <html lang="en">
            <head>
                <meta charset="UTF-8">
                <title>HTML插值-插值绑定</title>
                <style>
                    .align-center {
                        text-align: center;
                    }
                </style>
            </head>
            <body>
            <div id="app" style="width: 800px;margin: 0 auto;">
                <h3>下拉框</h3>
                <select v-model="singleSelect">
                    <option value="汉代">汉代</option>
                </select>
                <p>{{singleSelect}}</p>

                <select multiple v-model="multiSelect">
                    <option value="汉代">汉代</option>
                    <option value="汉代">汉代</option>
                    <option value="汉代">汉代</option>
                    <option value="汉代">汉代</option>
                </select>
                <p>{{multiSelect.join(",")}}</p>
            </div>
            <script src="https://cdn.jsdelivr.net/npm/vue@2.5.16/dist/vue.min.js"></script>
            <script type="text/javascript">
                let vm = new Vue({
                    el: '#app',
                    data() {
                        return {
                            singleSelect: '唐代', // 设置默认值
                            multiSelect: [1,3]
                        }
                    }
                })
            </script>
            </body>
            </html>


    12.2 v-model 与 修饰符

        修饰符                         可用版本                    说明
        .lazy                           所有                      将用户输入的数据赋值于变量的时机由输入时延迟到数据改变时
        .number                         所有                      自动转换用户输入为数值类型
        .trim                           所有                      自动过滤用户输入的首尾空白字符


        代码实例如下：
            <!DOCTYPE html>
            <html lang="en">
            <head>
                <meta charset="UTF-8">
                <title>HTML插值-插值绑定</title>
                <style>
                    .align-center {
                        text-align: center;
                    }
                </style>
            </head>
            <body>
            <div id="app" style="width: 800px;margin: 0 auto;">
                <input type="text" v-model.trim.number="text" @keyup="handleKeyUp"/>
            </div>
            <script src="https://cdn.jsdelivr.net/npm/vue@2.5.16/dist/vue.min.js"></script>
            <script type="text/javascript">
                let vm = new Vue({
                    el: '#app',
                    data: () => (
                        {
                            text : ''
                        }
                    ),
                    methods:{
                        handleKeyUp() {
                            console.log(this.text,typeof this.text);
                        }
                    }

                })
            </script>
            </body>
            </html>

    12.3 v-model 与 自定义组件
        代码实例如下：
            <!DOCTYPE html>
            <html lang="en">
            <head>
                <meta charset="UTF-8">
                <title>HTML插值-插值绑定</title>
                <style>
                    .align-center {
                        text-align: center;
                    }
                </style>
            </head>
            <body>
            <div id="app" style="width: 800px;margin: 0 auto;">
                <!-- 自定义组件 -->
                <custom-screen v-model="text"></custom-screen>
                <!-- 原生元素  -->
                <input type="text" id="it" v-model.trim.number="text"/>
            </div>
            <script src="https://cdn.jsdelivr.net/npm/vue@2.5.16/dist/vue.min.js"></script>
            <script type="text/javascript">

                Vue.component(
                    'custom-screen',
                    {
                        props: ['value'],
                        methods: {
                            handleReset() {
                                console.log("重置为\'\'");
                                this.$emit('input','') ; // 使用 $emit 发送 input 事件，并将目标值作为 参数传出
                            }
                        },
                        template: `<div>
                          <h2>输入值为： {{value}}</h2>
                          <button @click="handleReset">重置为空</button>
                        </div>
                        `
                    }
                )

                let vm = new Vue({
                    el: '#app',
                    data: () => (
                        {
                            text : ''
                        }
                    )
                })
            </script>
            </body>
            </html>
        在自定义组件中，value属性和input事件尤为重要，他们分别负责不同方向的数据传递。value属性用于接收外部传入的值以更新组件内部的状态，
        input事件由开发者决定在什么时候调用，并负责将组件内部的状态同步到外部。


        但是像单选框、复选框等类型的输入控件可能会将 value attribute 用于不同的目的。model 选项可以用来避免这样的冲突：

            Vue.component('base-checkbox', {
              model: {
                prop: 'checked',
                event: 'change'
              },
              props: {
                checked: Boolean
              },
              template: `
                <input
                  type="checkbox"
                  v-bind:checked="checked"
                  v-on:change="$emit('change', $event.target.checked)"
                >
              `
            })
        现在在这个组件上使用 v-model 的时候：这里的 lovingVue 的值将会传入这个名为 checked 的 prop。
        同时当 <base-checkbox> 触发一个 change 事件并附带一个新的值的时候，这个 lovingVue 的 property 将会被更新。




13. 条件渲染和列表渲染
    13.1 条件渲染
        13.1.1 指令 v-if
            只需要为元素挂上 v-if 指令即可，与之配套的还有 v-else 和 v-else-if，不过，它们只能与 v-if 配合使用。
            代码实例如下：
                <!DOCTYPE html>
                <html lang="en">
                <head>
                    <meta charset="UTF-8">
                    <title>HTML插值-插值绑定</title>
                    <style>
                        .align-center {
                            text-align: center;
                        }
                    </style>
                </head>
                <body>
                <div id="app" style="width: 800px;margin: 0 auto;">
                    <h2 v-if="order === 0">站在前排 v-if</h2>
                    <h2 v-else-if="order === 1">不上不下 v-else-if</h2>
                    <h2 v-else>负责垫后的 v-else</h2>

                    <button @click="toggleTitle">切换标题 </button>
                </div>
                <script src="https://cdn.jsdelivr.net/npm/vue@2.5.16/dist/vue.min.js"></script>
                <script type="text/javascript">
                    let vm = new Vue({
                        el: '#app',
                        data () {
                            return {
                                order : 0
                            }
                        },
                        methods:{
                            toggleTitle() {
                                this.order  = ++this.order % 3;
                                console.log("order 的 值：",this.order);
                            }
                        }
                    })
                </script>
                </body>
                </html>

        13.1.2 指令 v-show
            v-show 可以用于实现条件渲染，不过它只是简单地切换元素的CSS属性：display。当条件判断为假时，元素的display属性将被赋予为none，反之，元素的display属性将恢复为原有值
            相对于 v-if 来说，v-show 并不算作真正的条件渲染，因为 挂载它的多个元素之间没有上下文关系。
            代码实例如下：
                <!DOCTYPE html>
                <html lang="en">
                <head>
                    <meta charset="UTF-8">
                    <title>HTML插值-插值绑定</title>
                    <style>
                        .align-center {
                            text-align: center;
                        }
                    </style>
                </head>
                <body>
                <div id="app" style="width: 800px;margin: 0 auto;">
                    <h2 v-show="visible">v-show , visible = true</h2>
                    <h2 v-show="!visible">v-show , visible = false</h2>
                    <h2 v-if="visible">v-if , visible = true</h2>
                    <h2 v-else>v-else , visible = false</h2>
                </div>
                <script src="https://cdn.jsdelivr.net/npm/vue@2.5.16/dist/vue.min.js"></script>
                <script type="text/javascript">
                    let vm = new Vue({
                        el: '#app',
                        data () {
                            return {
                                visible : false
                            }
                        }
                    })
                </script>
                </body>
                </html>

            注意：
                1. v-if 会在切换中将组件上的事件监听器和子组件销毁和重建。当组件被销毁时，它将无法被任何方式获取，因为它已不存在于DOM中
                2. 在创建父组件时，如果子组件的 v-if 被判定为假，vue 不会对子组件做任何事情，直到第一次判定为真时。这在使用vue生命周期钩子函数时尤为重要，
                    如果生命周期已走过组件创建的阶段，却仍然无法获取组件对象，想一想，是不是 v-if 在作怪
                3. v-show 有更高的初始渲染开销，而 v-if 有更高的切换开销，这与它们的实现机制有关，在使用时要多加考虑具体的应用场景
                4. v-show 不支持 template 元素，不过在 vue2.0 中，template 的应用 并不广泛

    13.2 列表渲染
        13.2.1 指令 v-for
            v-for 用于 实现列表渲染，可以使用 item in items 或者 item of items 的语法，代码如下：
                <!DOCTYPE html>
                <html lang="en">
                <head>
                    <meta charset="UTF-8">
                    <title>HTML插值-插值绑定</title>
                    <style>
                        .align-center {
                            text-align: center;
                        }
                    </style>
                </head>
                <body>
                <div id="app" style="width: 800px;margin: 0 auto;">
                    <div style="float: left;width: 160px;">
                        <h2>用户列表</h2>
                        <ul>
                            <!-- index 作为第二个参数，用以标识下标 -->
                            <li v-for="(item ,index) in users" >{{index}}.&nbsp;{{item.name}}</li>
                        </ul>
                    </div>

                    <div style="margin-left: 170px; overflow: hidden">
                        <h2>用户列表</h2>
                        <ul>
                            <li v-for="(user,uIndex) of users">{{uIndex}}.&nbsp;{{user.name}}</li>
                        </ul>
                    </div>
                </div>
                <script src="https://cdn.jsdelivr.net/npm/vue@2.5.16/dist/vue.min.js"></script>
                <script type="text/javascript">
                    let vm = new Vue({
                        el: '#app',
                        data () {
                            return {
                                users : [
                                    {name:'Clark',age:27,city:'Chicago'},
                                    {name:'Jackson',age:28,city:'Sydney'}
                                ]
                            }
                        }
                    })
                </script>
                </body>
                </html>

            除了能渲染数组外，还可以渲染一个对象的键值对,代码如下：
                <!DOCTYPE html>
                <html lang="en">
                <head>
                    <meta charset="UTF-8">
                    <title>HTML插值-插值绑定</title>
                    <style>
                        .align-center {
                            text-align: center;
                        }
                    </style>
                </head>
                <body>
                <div id="app" style="width: 800px;margin: 0 auto;">
                    <div style="float: left;width: 160px;">
                        <h2>用户列表</h2>
                        <ul>
                            <!-- index 作为第二个参数，用以标识下标 -->
                            <li v-for="(user ,index) in users">
                                用户 {{ index + 1 }}
                                <ul>
                                    <li v-for="(value ,key) of user">{{ key }}：&nbsp;{{ value }}</li>
                                </ul>
                            </li>
                        </ul>
                    </div>
                </div>
                <script src="https://cdn.jsdelivr.net/npm/vue@2.5.16/dist/vue.min.js"></script>
                <script type="text/javascript">
                    let vm = new Vue({
                        el: '#app',
                        data() {
                            return {
                                users: [
                                    {name: 'Clark', age: 27, city: 'Chicago'},
                                    {name: 'Jackson', age: 28, city: 'Sydney'}
                                ]
                            }
                        }
                    })
                </script>
                </body>
                </html>

            Vue 会把数组当作被观察者 加入响应式系统中，当调用一些方法修改数组时，对应的视图将会同步更新。
            与数据响应有关的数组方法:
                名称              说明
                push                将一个或多个元素添加至数组末尾，并返回新数组的长度
                pop                 从数组中删除并返回最后一个元素
                shift               从数组中删除并返回第一个元素
                unshift             将一个或多个元素添加至数组开头，并返回新数组的长度
                splice              从数组中删除元素或向数组添加元素
                sort                对数组元素排序，默认按照Unicode编码排序，返回排序后的数组
                reverse             将数组中的元素位置颠倒，返回颠倒后的数组

            代码实例如下：
                <!DOCTYPE html>
                <html lang="en">
                <head>
                    <meta charset="UTF-8">
                    <title>HTML插值-插值绑定</title>
                    <style>
                        .align-center {
                            text-align: center;
                        }
                    </style>
                </head>
                <body>
                <div id="app" style="width: 800px;margin: 0 auto;">
                    <div style="float: left;width: 160px;">
                        <h2>用户列表</h2>
                        <button @click="createUser">创建用户</button>
                        <button @click="reverse">倒序数组</button>
                        <ul>
                            <!-- index 作为第二个参数，用以标识下标 -->
                            <li v-for="(user ,index) in users">
                                用户 {{ index + 1 }}
                                <ul>
                                    <li v-for="(value ,key) of user">
                                        <strong style="display: inline-block;width: 60px;">{{key}}:</strong>
                                        <span>{{value}}</span>
                                    </li>
                                </ul>
                            </li>
                        </ul>
                    </div>
                </div>
                <script src="https://cdn.jsdelivr.net/npm/vue@2.5.16/dist/vue.min.js"></script>
                <script type="text/javascript">
                    let vm = new Vue({
                        el: '#app',
                        data() {
                            return {
                                users: []
                            }
                        },
                        methods:{
                            random(factor,base) { // 根据乘积因子和基数生成随机整数
                                return Math.floor(Math.random() * (factor || 1)) + (base || 0)
                            },
                            createUser() {
                                // 获取name 大写首字母
                                let fLetter = 'BJHK'[this.random(3.999)];
                                // 随机截取 name 字符串
                                let nameStr = 'abcdefghijklmnopqrstuvwxyz';
                                let bLetter = nameStr.substr(this.random(3.999), this.random(3.999, 3));
                                let user = {
                                    name: fLetter + bLetter,
                                    age: this.random(5.999, 25),
                                    city: ['Chicago', 'Sydney', 'Shenzhen', 'Hangzhou'][this.random(3.999)]
                                }

                                console.log("=======================创建用户========================\n", user);
                                this.users.push(user);
                            },
                            reverse() {
                                console.log("=======================倒序列表=============================")
                                console.log('Before',this.users.map(user => user.name));
                                this.users.reverse();
                                console.log('After',this.users.map(user => user.name));

                            }
                        }
                    })
                </script>
                </body>
                </html>

            要注意：
                直接使用 下标/键名为数组/对象设置成员时，有以下用法：
                    arr[0] = 99  // 使用索引为数组设置成员
                    obj['key'] = 'value' // 使用键名为对象设置成员
                Vue并不会将其加入数据响应式系统，因此当数据被修改时，视图不会进行更新。

        13.2.2 列表渲染中的key
            在使用 v-for时，最好为每个迭代元素提供一个值不重复的key
            当列表渲染被重新执行时，如果不使用key，vue 会为数组成员就近复用已存在的DOM节点，如下所示：

                数组成员1       DOM节点1                                                  数组成员3                           DOM节点1

                数组成员2       DOM节点2       --->       当数组发生变化时    --->          数组成员1                           DOM节点2

                数组成员3       DOM节点3                                                  数组成员2                           DOM节点3

            当使用key时，Vue会根据key的变化重新排列节点顺序，并移除key不存在的节点
                数组成员1       DOM节点1                                                  数组成员3                           DOM节点3

                数组成员2       DOM节点2       --->       当数组发生变化时    --->          数组成员1                           DOM节点1

                数组成员3       DOM节点3                                                  数组成员2                           DOM节点2


            实质上，key 的存在是为DOM节点标注了一个身份信息，让Vue能够有迹可循追踪到数据对应的节点。在实战开发中，是否使用key都不会影响功能的实现。

14. 选项
    14.1 数据选项
        数据（data）选项可接收的类型有对象和函数两种，
        定义一个组件时，数据选项只能接收函数类型。
        代码实例如下：
            <!DOCTYPE html>
            <html lang="en">
            <head>
                <meta charset="UTF-8">
                <title>HTML插值-插值绑定</title>
                <style>
                    .align-center {
                        text-align: center;
                    }
                </style>
            </head>
            <body>
            <div id="app" style="width: 800px;margin: 0 auto;">
                <h1>{{title}}</h1>
                <button-counter></button-counter>
            </div>
            <script src="https://cdn.jsdelivr.net/npm/vue@2.5.16/dist/vue.min.js"></script>
            <script type="text/javascript">
                Vue.component('button-counter',{
                    data () {
                        return {
                            counter: 1
                        }
                    },
                    template : '<button @click="counter++">clicked {{counter}} times</button>'
                })


                // let vm = new Vue({
                //     el : '#app',  // mount 到 DOM 上
                //     data : {  // 对象类型
                //         title: 'A Vue App'
                //     }
                // })

                let vm = new Vue({
                    el : '#app', // mount 到 DOM 上
                    data() {   //函数类型
                        return {
                            title:'A Vue App'
                        }
                    }
                })
            </script>
            </body>
            </html>

        在vue中声明组件时，如果使用了对象类型的data选项，模板将找不到在data中声明的数据。如果使用了支持vue模板的语法检察权，开发者将得到错误提示 ‘data property in component must be a function’


        Vue 会递归地将data选项中的数据加入响应式系统，但这些数据应该是声明的时候即存在的。下面 来看一段代码 （单文件组件模板）:
            <template>
                <div>
                    <h2>{{title}}</h2>
                    <p>{{profile}}</p>
                </div>
            </template>

            <script>
                export default{
                    name:'Instance',
                    data () {
                        return {
                            title : 'A Vue App'
                        }
                    },
                    created () {
                        Object.assign(this.$data,{  // 为对象赋值属性，没有则添加属性，有则覆盖原有的属性值
                            profile : 'This is a Vue App'
                        })

                        console.log(this.$data)
                    }
                }
            </script>

        title 是在初始化实例时声明在data选项中的数据，而profile则是在created钩子函数中被赋予data选项的。可以看出，profile被赋予data选项后，视图没有发生任何变化，这是因为
        vue在处理数据时，并未把profile加入数据响应式系统。又因为 profile 是在实例创建完成后被绑定到组件上的，所以vue给出了错误提示 ‘profile is not defined’。
        此时的profile 只是一个普通js属性，而非被vue观察的对象。

        在实际开发中，应将可能在实例中被观察的对象预先在data选项中声明，以任何浏览器所支持的原生api 都无法将数据动态加入响应式系统，不过vue针对这一需求，也提供了响应的机制。
        开发者可以使用 $set 方法 为 data 选项动态绑定数据，但其也无法挂载响应数据到data根节点。不过，既然这些数据要绑定到 $data 根节点上，何不在初始化时声明呢？

        $set 用法如下：
            /**
             * target 目标对象     Object | Array
             * key    键名         String | Number
             * value 键值          任意类型
             */
             // Vue.set(target,key,value)
             created () {
                this.$set(target,key,value)
             }

        下面将分别演示使用原生方法 Object.assign 和 Vue.$set为组件挂载响应式数据的实例
        关于 Object.assign的代码如下：
            <template>
                <div>
                    <h2>{{title}}</h2>
                    <p>{{obj.profile}}</p>
                    <button @click="toggle">toggle</button>
                </div>
            </template>
            <script>
                export default {
                    name : 'instance',
                    data () {
                        return {
                            title : 'A Vue App',
                            obj : {}  // $set 不能用在根节点 data 上
                        }
                    },

                    created () {
                        Object.assign(this.obj,{
                            profile : 'This is a Vue App'
                        })

                        console.log('created',this.obj)
                    },

                    mounted () {
                         Object.assign(this.obj,{
                            profile : 'This is a Vue Test App'
                        })

                        console.log('created',this.obj)
                    },

                    methods : {
                        toggle () {
                            Object.assign(this.obj,{
                                profile : 'This is a Vue App for test'
                            })

                            console.log('toggle',this.obj)
                        }
                    }

                }
            </script>

        相比之前使用 Object.assign 的示例，这次的视图表现更显奇怪，vue不仅没有提示错误，还响应了在 created 钩子函数 中所做的修改，从
        生命周期角度分析：
            1. 在组件实例被创建式 （beforeCreate 和 create 之间）时，obj对象作为 data选项的属性存在与实例中，且拥有合法的地址
            2. 在created 钩子函数中，将profile挂载在obj对象上，obj.profile 由undefined 变为 被赋予的值。由于 obj.profile 被赋值时，实例
                已经过了将数据加入响应式系统的阶段，所以 ob.profile 并未被观察。又因为实例尚未和Dom节点绑定（beforeMount
                ），所以此时修改 profile 依然可以影响之后的视图表现（profile的视图表现是在实例created时被赋予的）。
            3. 在mounted钩子函数和click事件中，由于实例已经绑定到DOM节点上且profile不存在于响应式系统中，所以此时修改profile，视图没有发生变化。

        将代码稍作修改，在created中以 $set 的方式为对象绑定属性，代码如下：
            created () {
                this.$set(this.obj,'profile','This is a Vue App'
                console.log('created',this.obj)
            }
        此时的profile被加入vue 的响应式系统，当笔者点击按钮时，视图也发生了变化，
        需要注意的是：不要将已有内存地址的对象用于data选项，我们应该创建新对象。

        已有内存地址的代码如下：
            <div id="app">
                <button-counter></button-counter>
                <button-counter></button-counter>
            </div>
            <script src="https://cdn.jsdelivr.net/npm/vue@2.5.16/dist/vue.min.js"></script>
            <script>
                let jack = {counter:0};
                Vue.component('button-counter',{
                    data () {
                        return jack;
                    },
                    template : '<button @click="counter++">click {{{counter}} </button>'
                })

                let vm = new Vue({
                    el: '#app'

                });
            </script>

        使用创建新的对象：
             <div id="app">
                <button-counter></button-counter>
                <button-counter></button-counter>
            </div>
            <script src="https://cdn.jsdelivr.net/npm/vue@2.5.16/dist/vue.min.js"></script>
            <script>

                Vue.component('button-counter',{
                    data () {
                        return {
                            counter: 0
                        }


                    },
                    template : '<button @click="counter++">click {{{counter}} </button>'
                })

                let vm = new Vue({
                    el: '#app'

                });
            </script>

            或者使用 JSON.parse(JSON.stringify(obj))深拷贝已有对象
                <div id="app">
                    <button-counter></button-counter>
                    <button-counter></button-counter>
                </div>
                <script src="https://cdn.jsdelivr.net/npm/vue@2.5.16/dist/vue.min.js"></script>
                <script>
                    let jack = {counter:0};
                    Vue.component('button-counter',{
                        data () {
                            return JSON.parse(JSON.stringify(jack));
                        },
                        template : '<button @click="counter++">click {{{counter}} </button>'
                    })

                    let vm = new Vue({
                        el: '#app'

                    });
                </script>

            以上两种方式，目的都是为实例的data选项分配一个新的内存地址.

    14.2 属性选项
        Vue 为组件开发提供了 属性【props】 选项，我们可以使用它为组件注册动态特性，处理业务间的差异，使代码可以复用于相似的应用场景。

        props 选项可以是数组或者对象类型，用于接收从 父组件 传递过来的参数，并允许开发者为其设置默认值，类型检测和校验规则等。
        代码如下：
            <div id="app">
                <color-text text="Hello World"></color-text>
                <br>
                <color-text></color-text>
                <br>
                <color-text color="#f78" text="Hello World"></color-text>
                <br>
                <color-text color="#43dt" text="Hello World"></color-text>
            </div>
            <script src="https://cdn.jsdelivr.net/npm/vue@2.5.16/dist/vue.min.js"></script>
            <script>
                Vue.component('color-text',{
                    props:{
                        text: String,
                        color : {
                            type:String,
                            default:'#000',
                            required:true,
                            validator () {
                                return /^([0-9a-fA-F]{6}|[0-9a-fA-F]{3})$/.test(value);
                            }
                        }
                    },
                    template : '<span :style="{color:color}">{{text}}</span>'
                })

                let vm = new Vue({
                    el:'#app'
                })
            </script>

    14.3 方法选项
        代码1：
            let store1 = {
                msg : 'Hello World',
                logMSG () {
                    console.log("=================匿名函数=========================")
                    console.log(this.msg)
                }
            }

            store1.logMsg();

        代码2：
            let store2 = {
                msg : 'Hello World',
                logMSG : () => {
                    console.log("=================箭头函数=========================")
                    console.log(this.msg)
                }
            }

            store2.logMsg();

        使用 箭头函数 定义方法时并不会创建函数作用域，因此 this 也不会指向其父级实例，此时的this会向上追踪，当找到某本函数作用域时，this将指向该函数的父级实例；
        否则，this将指向浏览器的内置对象 window

        methods 选项 不能使用箭头函数 在其中定义方法。在创建组件时，methods中的方法将被绑定到vue实例上，方法中的this也将自动指向vue实例。

    14.4 计算属性
        计算属性 computed 选项 设计的初衷在于减轻模板上的业务负担，当数据链上出现复杂的衍生数据时，期望以一种易维护的方式使用它
        下面示例没有使用 computed 属性的场景：
            <!DOCTYPE html>
            <html lang="en">
            <head>
                <meta charset="UTF-8">
                <title>计算属性</title>
            </head>
            <body>
            <div id="app" style="font-family: Roboto,sans-serif; color : rgb(84.92.100);margin-left: 100px;">
                <h2>英语中的“互文”</h2>
                <p>我们先来看三句话 (代码)：</p>
                <p>{{message}}.&nbsp;&nbsp;我看到的是车还是猫。</p>
                <p>{{message.replace(/\s/g,'')}}</p>
                <p>{{message.replace(/\s/g,'').split('').reverse().join('')}}</p>
                <p>英语中也有“互文”的修辞手法，比如{{message}}这句话</p>
                <p>将句中空格去掉可得 {{message.replace(/\s/g,'')}},</p>
                <p>将句中空格去掉并将其倒序可得 {{message.replace(/\s/g,'').split('').reverse().join('')}}.</p>
                <p>可以看到，{{message.replace(/\s/g,'')}} = {{message.replace(/\s/g,'').split('').reverse().join('')}}，</p>
                <p>这是互文英语的一个示例</p>
            </div>
            <script src="https://cdn.jsdelivr.net/npm/vue@2.5.16/dist/vue.min.js"></script>
            <script type="text/javascript">

                let vm = new Vue({
                    el : '#app', // mount 到 DOM 上
                    data() {   //函数类型
                        return {
                            message : 'WAS IT A CAR OR A CAT I SAW'
                        }
                    }
                })
            </script>
            </body>
            </html>

        基于 computed 选项 重构的示例：
            <!DOCTYPE html>
            <html lang="en">
            <head>
                <meta charset="UTF-8">
                <title>计算属性</title>
            </head>
            <body>
            <div id="app" style="font-family: Roboto,sans-serif; color : rgb(84.92.100);margin-left: 100px;">
                <h2>英语中的“互文”</h2>
                <p>我们先来看三句话 (代码)：</p>
                <p>{{message}}.&nbsp;&nbsp;我看到的是车还是猫。</p>
                <p>{{noSpaceMsg}}</p>
                <p>{{palindromeMsg}}</p>
                <p>英语中也有“互文”的修辞手法，比如{{message}}这句话</p>
                <p>将句中空格去掉可得 {{noSpaceMsg}},</p>
                <p>将句中空格去掉并将其倒序可得 {{palindromeMsg}}.</p>
                <p>可以看到，{{noSpaceMsg}} = {{palindromeMsg}}，</p>
                <p>这是互文英语的一个示例</p>
            </div>
            <script src="https://cdn.jsdelivr.net/npm/vue@2.5.16/dist/vue.min.js"></script>
            <script type="text/javascript">

                let vm = new Vue({
                    el : '#app', // mount 到 DOM 上
                    data() {   //函数类型
                        return {
                            message : 'WAS IT A CAR OR A CAT I SAW'
                        }
                    },
                    computed : {
                        noSpaceMsg() {
                            return this.message.replace(/\s/g,'')
                        },
                        palindromeMsg() {
                            return this.message.replace(/\s/g,'').split('').reverse().join('');
                        }
                    }
                })
            </script>
            </body>
            </html>

        与methods 一样，computed 不能以箭头函数声明，同时 它也会被混入 vue示例，并可通过this调用。
        由于 计算属性 依赖于 响应式属性，所以当且仅当 响应式属性变化时，计算属性才会被重新计算，而且得到的结果将会被缓存，一直到响应式属性再次被修改时。
        相比于methods函数求值，这是一种更为高效的机制。

        vue允许开发者为computed属性赋值
        开发者有权定义可被赋值的computed属性，方法类似于定义对象属性描述符中的setter和getter。示例代码如下：
            <!DOCTYPE html>
            <html lang="en">
            <head>
                <meta charset="UTF-8">
                <title>计算属性</title>
            </head>
            <body>
            <div id="app">
                <h2>数据变化之前
                    <i style="color:#ababab;font-size: 14px;">
                        * 指令 v-once 可以限制 视图不再响应数据变化
                    </i>
                </h2>
                <p v-once>{{message}}</p>
                <p v-once>{{noSpaceMsg}}</p>
                <h2>数据变化之后</h2>
                <p>{{message}}</p>
                <p>{{noSpaceMsg}}</p>
            </div>
            <script src="https://cdn.jsdelivr.net/npm/vue@2.5.16/dist/vue.min.js"></script>
            <script type="text/javascript">

                let vm = new Vue({
                    el : '#app', // mount 到 DOM 上
                    data() {   //函数类型
                        return {
                            message : 'WAS IT A CAR OR A CAT I SAW'
                        }
                    },
                    computed : {
                        noSpaceMsg : {
                            set (value) {
                                this.message = value;
                            },

                            get () {
                                return this.message.replace(/\s/g,'');
                            }
                        }
                    }
                })
            </script>
            </body>
            </html>

    14.5 侦听属性
        Vue 允许开发者使用侦听属性（watch选项）为实例添加被观察对象，并在对象被修改时调用开发自定义的方法。
        代码如下：
            <!DOCTYPE html>
            <html lang="en">
            <head>
                <meta charset="UTF-8">
                <title>计算属性</title>
            </head>
            <body>
            <div id="app">
                <h2>数据变化之前
                    <i style="color:#ababab;font-size: 14px;">
                        * 指令 v-once 可以限制 视图不再响应数据变化
                    </i>
                </h2>
                <p v-once>{{message}}</p>
                <p v-once>{{noSpaceMsg}}</p>
                <h2>数据变化之后</h2>
                <p>{{message}}</p>
                <p>{{noSpaceMsg}}</p>
            </div>
            <script src="https://cdn.jsdelivr.net/npm/vue@2.5.16/dist/vue.min.js"></script>
            <script type="text/javascript">

                let vm = new Vue({
                    el : '#app', // mount 到 DOM 上
                    data() {   //函数类型
                        return {
                            message : 'WAS IT A CAR OR A CAT I SAW',
                            noSpaceMsg : 'WASITACARORACATISAW'
                        }
                    },
                    watch : { // 使用watch实现，当元数据变化时，同步衍生数据的状态
                        message (newValue,oldValue) {  // message: 表示被观测的对象属性，如 data选项中的 message,事实证明，有没有参数都一样可以实现
                            this.noSpaceMsg = this.message.replace(/\s/g,'');
                        }
                    }
                })
            </script>
            </body>
            </html>
        由于 watch 更注重于处理数据变化时的业务逻辑，而computed 更注重于衍生数据，因此，与 computed 相比，watch 还优于 可以异步修改数据。
        代码如下：
            import axios from 'axios'
            let vm = new Vue({
                el : '#app',
                data () {
                    return {
                        message : '书山有路勤为径，学海无涯苦作舟',
                        remoteMsg: ''
                    }
                },
                watch : {
                    message(newValue,oldValue ){
                        axios ({
                            method:'GET',
                            url: '/someurl',
                            params: {
                                message : newValue
                            }
                        }).then(res => {
                            this.remoteMsg = res.data.message; // 接收响应后，异步修改数据
                        })
                    }
                }
            })

        vue 还为watch提供了丰富的声明方式，代码如下：
            let vm = new Vue({
                el:'#app',
                data() {
                    return {
                        msg: {
                            sender:'Jack',
                            receiver: 'Rose'
                        }
                    }
                },
                methods: {
                    logLine() {
                        console.log("===========================分割线============================")
                    },
                    logMsg(newValue,oldValue) {
                        console.log(newValue)
                    }
                },
                watch: {
                    msg :{
                        handler : 'logMsg',
                        deep: true, // 深度冠词，对象任何层级数据发生变化，watch方法都会被触发
                        immediate : true // 立即调用： 在侦听开始时立即调用一次watch方法
                    },
                    'msg.sender':['logLine','logMsg'] // 数组方式，可以调用多个方法
                }
            })


    14.6 DOM渲染
        14.6.1 指定被挂载元素
            el 选项 可用于指定 vue实例的挂载目标，属性值仅限于 CSS 选择器 或者DOM节点对象
            代码如下：
                <style>
                    .fixed-width {
                        display:inline-block;
                        width: 100px;
                    }
                </style>
                <p id="app"><strong class="fixed-width">CSS选择器：</strong>{{ msg }}</p>
                <p id="app2"><strong class="fixed-width">DOM节点：</strong>{{ msg }}</p>
                <p id="app3"><strong class="fixed-width">手动挂载：</strong>{{ msg }}</p>
                <button onclick="handleMount()">手动挂载</button>
                <script src="https://cdn.jsdelivr.net/npm/vue@2.5.16/dist/vue.min.js"></script>
                <script>
                    let vm = new Vue({
                        el:'#app',
                        data() {
                            return {
                                msg : 'Hello World'
                            }
                        }
                    })

                    let vm2 = new Vue({
                        el: document.getElementById('app2'),
                        data() {
                            return {
                                msg : 'Hello World'
                            }
                        }
                    })

                    let vm3 = new Vue({

                        data() {
                            return {
                                msg : 'Hello World'
                            }
                        }
                    })

                    let handleMount = function() {
                        vm3.$mount("#app3");
                    }
                </script>

            上述三种方式得到的结果都一样

        14.6.2  视图的字符串模板
            Vue 允许开发者使用字符串作为实例的模板，模板字符串有 template 选项接收，示例代码如下：
                <div id="app">target element</div>
                <script src="https://cdn.jsdelivr.net/npm/vue@2.5.16/dist/vue.min.js"></script>
                <script>
                    let vm = new Vue({
                        el:'#app',
                        template : '<h1>template element</h1>'   // 模板节点将替换原有的DOM节点
                    })
                </script>

        14.6.3 渲染 函数 render
            render 函数同样也可以用于渲染视图，它提供了回调方法 createElement 以供我们创建 DOM节点。
            代码如下：
                <!DOCTYPE html>
                <html lang="en">
                <head>
                    <meta charset="UTF-8">
                    <title>渲染函数 render</title>
                    <style>
                        .btn {
                            outline: none;
                            border: none;
                            cursor: pointer;
                            padding: 5px 12px;
                        }

                        .btn-text {
                            color: #409eff;
                            background-color: transparent;
                        }

                        .btn-text:hover {
                            color: #66b1ff
                        }
                    </style>
                </head>
                <body>
                <div id="app">
                    <fly-table :fields="fields" :goods="goods">
                        <span slot="title">Fly Table COmponent</span>
                    </fly-table>
                </div>

                <script src="https://cdn.jsdelivr.net/npm/vue@2.5.16/dist/vue.min.js"></script>
                <script type="text/javascript">
                    Vue.component('fly-table', {
                        props: {
                            fields: {
                                type: Array,
                                default() {
                                    return [];
                                }
                            },
                            goods: {
                                type: Array,
                                default() {
                                    return [];
                                }
                            }
                        },
                        methods: {
                            reverse() {
                                this.goods.reverse();
                            }
                        },

                        /**
                         * -render函数
                         * -参数：createElement函数
                         * -返回值：必须返回一个createElement函数的调用结果，也就是模版内的顶层元素（这个方法在vue2的习惯性使用中经常用h来命名）
                         */
                        render(createElement) {

                            /**
                             * -createdElement 的三个参数
                             * 1. HTML 标签字符串 （String） | 组件选项对象 （Object） | 节点解析函数 （Function）
                             * 2. 定义节点特性的对象 （Object）
                             * 3. 子节点，createElement 构建的 VNode 节点 或字符串生成的无标签文本节点 （Array | String）
                             */
                            return createElement('div', {
                                // 作为子组件时的插槽名称
                                slot: 'fly-table'
                            }, [
                                createElement('h2', this.$slots.title),
                                createElement('button', {
                                    // clas 用于绑定类名，同 v-bind:class 的绑定方式
                                    class: ['btn', 'btn-text'],
                                    // attrs 用于绑定节点一般属性，如 id、disabled、title 等
                                    attrs: {
                                        disabled: false,
                                        title: '点击是数组倒序'
                                    },
                                    // domProps 用于绑定节点DOM属性 如 innerHTML  innerText
                                    domProps: {
                                        innerText: '倒序'
                                    },
                                    on: {
                                        // 绑定点击事件，使用箭头函数以免创建函数作用域
                                        click: () => {
                                            this.goods.reverse();
                                        }
                                    },
                                    // 自定义命令
                                    directives: [],
                                    // 其他属性
                                    key: 'btnReverse',
                                    ref: 'btnReverse'
                                }),

                                createElement('table', {
                                    // style 绑定样式 ，同 v-bind:style 的绑定方式
                                    style: {
                                        width: '400px',
                                        textAlign: 'left',
                                        lineHeight: '42px',
                                        border: '1px solid #eee',
                                        userSelect: 'none'

                                    }
                                }, [
                                    createElement('tr', [
                                        this.fields.map(field => createElement('th', field.prop))
                                    ]),

                                    this.goods.map(item => createElement('tr', {
                                            style: {
                                                color: item.isMarked ? '#ea4335' : ''
                                            }
                                        },
                                        this.fields.map(field => createElement('td', {style: {borderTop: '1px solid #eee'}}, [
                                            // 如果不是操作列，显示文本，否则显示按钮
                                            field.prop !== 'operate' ? createElement('span', item[field.prop]) : createElement('button', {
                                                class: ['btn', 'btn-text'],
                                                domProps: {
                                                    innerHTML: '<span>切换标记</span>'
                                                },
                                                on: {
                                                    click: () => {
                                                        item.isMarked = !item.isMarked;
                                                    }
                                                }
                                            })
                                        ]))
                                    ))

                                ])
                            ]);
                        }
                    })

                    let vm = new Vue({
                        el: '#app',
                        data() {
                            return {
                                fields: [
                                    {
                                        label:'名称',
                                        prop: 'name'
                                    },
                                    {
                                        label:'数量',
                                        prop: 'quantity'
                                    },
                                    {
                                        label:'价格',
                                        prop: 'price'
                                    },
                                    {
                                        label:'操作',
                                        prop: 'operate'
                                    }
                                ],

                                goods: [
                                    {
                                        name : '苹果',
                                        quantity: 200,
                                        price: 6.8,
                                        isMarked : false
                                    },

                                    {
                                        name : '西瓜',
                                        quantity: 50,
                                        price: 4.8,
                                        isMarked : false
                                    },

                                    {
                                        name : '榴莲',
                                        quantity: 0,
                                        price: 22.8,
                                        isMarked : false
                                    },
                                ]

                            }
                        }
                    })
                </script>
                </body>
                </html>

            template 和 render 选项均是用于增加JS代码以减少 HTML 代码的开发，这样做的好处有两个：
                1. 使开发者可以聚焦于JS代码的书写
                2. 更贴近于Vue的底层编译器
            相比于template，reendee函数充分地体现了JS的完全编程能力（脱离html和css代码的开发）

            借助于 babel-plugin-transform-vue-jsx插件，开发者亦可以使用JSX语法


            事件修饰符
            修饰符                         前缀               说明
            .passive                        &               移动端，限制事件永不调用 preventDefault()方法
            .capture                        !               当事件触发时，阻止事件捕获
            .once                           ~               事件被触发一次后即解除监听
            .capture.once/.once.capture     ~!              事件被触发一次后即解除监听并阻止事件捕获

            用法如下：
                on: {
                    '!click':() =? {}, // .capture
                    '~keyup':() => {}, // .once
                    '~!mouseover': () => {} // .capture.once
                }


            其他的一些事件修饰符，开发者可以使用原生JS编写。如下：

            部分事件修饰符与原生JS的对照表
            修饰符                 原生JS
            .stop                   event.stopPropagation()
            .prevent                event.preventDefault()
            .self                   if(event.target  != event.currentTarget) return
            .enter/.13              if(event.keyCode !== 13) return
            .ctrl                   if(!event.ctrlKey) return

            用法如下：
                on : {
                    keyup: function(event) {
                        //.self
                        if(event.target !== event.currentTarget) return
                        // .shift && .enter(.13)
                        if(!event.shiftKey || event.keyCode !== 13) return
                        // .stop
                        event.stopPropagation()
                        // .prevent
                        event.preventDefault()
                    }
                }

            在HTML中，任何内容都是节点，即使没有标签的文本也是节点，层层节点嵌套，形成一颗DOM树。
            在DOM中查询和更新节点是一件比较低效的工作，为此，Vue提供了renter函数和虚拟DOM，虚拟DOM将对真实的DOM发生的变化进行跟踪，
            以降低DOM查询的用时。

            与 document.createElement不同的是，render的createElement创建的并不是真是的DOM节点，而是虚拟节点 （Virtual Node，VNode），
            含有开发者描述的信息。由VNode组成的树形结构即 “虚拟节点”，Vue将通过虚拟DOM在页面上渲染出真实的DOM


            在组件树中，VNode必须保持其身份唯一，以便vue一一对应地对每个真实的DOM节点进行跟踪

        14.6.4 选项优先级
            优先级             高低（越往后，优先级越低）
            render              1
            template            2
            el                  3


    14.7 封装复用
