1. 安装 cnpm
    npm install -g cnpm --registry=https://registry.npm.taobao.org

2. 安装 vue.js
    cnpm install -g vue
3. 安装 vue devtools

    下载 vue devtools
        https://github.com.vuejs/vue-devtools.git

    进入 vue-devtools目录下，安装构建工具所需的依赖
        cnpm install
    构建工具
        npm run build


4. vue 中的 data
    1. 在 vue 实例中 data 是一个对象，也可以是一个 函数
    2. 在 组件中，data 只能是一个函数，且必须返回一个对象


5. 什么是Vue
    Vue.js 是一款MVVM模式实现的轻量级，渐进式的JavaScript框架
    vue的核心库只关注视图层，并且提供尽可能简单的API以实现数据绑定、组件复用等机制，
    vue完全支持SPA设计和组合其他Vue生态库的系统


6. 数据响应式的原理
    Vue最重要的概念是响应式数据。一方面指元数据与衍生数据之间的响应，通过数据链来实现；另一方面指的是数据与视图之间的绑定

7. 函数式编程
    是一种结构化编程方式，力求将运算过程写成一系列嵌套的函数调用
    函数式编程认为函数可以赋值给其他变量、用作另一个函数的参数或者作为函数返回值来使用
    函数式编程的核心是根据元数据生成新的衍生数据，提供唯一确定的输入，函数将返回唯一确定的输出，且并不会修改原有变量的值。

8. Vue中的数据链
    Vue实例提供了computed计算属性，以供生成衍生数据对象。计算属性以函数形式声明，但是不接收参数，也只能以属性的方式调用。
    计算属性的this指向Vue实例，所以它可以获取实例上的所有已挂载的可见属性。

    对象属性配置表
    名称                                      默认值                         说明
    configurable                              false                         标识属性配置是否可以更改和该属性能否从对象中删除
    enumerable                                false                         标识属性是否可被枚举
    writable                                  false                         标识属性是否可通过赋值运算符修改，不与set共存
    value                                     undefined                     属性值，可为任意JS数据类型，不与set共存
    set                                       undefined                     函数类型，属性被赋值时调用
    get                                       undefined                     函数类型，返回值将作为属性值

    有关defineProperty的代码

    <span id="harry" style="line-height:32px"></span>
    <br>
    <input id="trigger" type="text" />
    <script>
        let harry = document.getElementById("harry");
        let trigger = document.getElementById("trigger");

        let key = "profile";
        let store = {};
        let obj = {
            profile: ''
        }

        Object.defineProperty(
            obj,
            key,
            {
                set (value) {
                    harry.innerText = value;
                    store[key] = value;
                },

                get () {
                    return store[key];
                }

            }
        )

        trigger.addEventListener('keyup',function {
            obj[key] = this.value;
            console.log(obj[key]);
        })
    </script>

    上述代码中，在对象属性的setter函数中修改文本节点的值，所以当obj.profile被重新赋值时，节点视图也会同步更新；然后对输入框添加监听事件当用户事件触发时，输入值将被赋于 obj.profile。
    以此方式，实现了数据与视图之间的 “双向绑定”。这也是Vue数据与视图绑定的实现原理.

9. 插值绑定
    9.1 文本插值
        只要用 双大括号（Mustache语法）将要绑定的变量、值、表达式括住就可以实现，vue将会获取计算后的值，并以文本的形式将其展示出来。
        实例代码：
            <!DOCTYPE html>
            <html lang="en">
            <head>
                <meta charset="UTF-8">
                <title>文本插值-插值绑定</title>
                <style>
                    .profile {
                        display: inline-block;
                        width: 300px;
                    }
                </style>
            </head>
            <body>
                <div id="app" style="margin-left: 300px">
                    <h2>文本插值</h2>
                    <p><label class="profile">变量：</label> {{num}}</p>
                    <p><label class="profile">表达式：</label> {{5 + 10}}</p>
                    <p><label class="profile">三目运算符：</label> {{true ? 15 : 10}}</p>
                    <p><label class="profile">函数：</label> {{getNum()}}</p>
                    <p><label class="profile">匿名函数：</label> {{ (() => 5 + 10)() }}</p>
                    <p><label class="profile">对象：</label> {{{num : 15} }}</p>
                    <p><label class="profile">函数对象：</label> {{ getNum }}</p>
                    <p><label class="profile">Html代码（表达式）：</label> {{ '<span>15</span>' }}</p>
                    <p><label class="profile">Html代码（变量）：</label> {{ html }}</p>
                </div>

                <script src="https://cdn.jsdelivr.net/npm/vue@2.5.16/dist/vue.min.js"></script>
                <script type="text/javascript">
                    let vm = new Vue({
                        el: '#app',
                        data () {
                            return {
                                num : 15,
                                html : '<span>15</span>'
                            }
                        },
                        methods : {
                            getNum() {
                                return this.num
                            }
                        }
                    })
                </script>
            </body>
            </html>

        关于 html（表达式）和 html（变量）的差异，对于前者来说，Vue优先解释了 DOM 节点 span ,并隔离了 {{ 和 }} ，所以插值语法并未生效， {{ 和 }} 还被当作了 p 节点的文本内容
    9.2 HTML插值
        HTML插值可以动态渲染DOM节点，常用于处理开发者无可预知和难以控制的DOM结构，如渲染用户随意书写的文档结构等。
        实例代码：` 是 ESC按键下的 一个符号
            <!DOCTYPE html>
            <html lang="en">
            <head>
                <meta charset="UTF-8">
                <title>HTML插值-插值绑定</title>
                <style>
                    .align-center {
                        text-align: center;
                    }
                </style>
            </head>
            <body>
                <div id="app" style="width: 800px;margin: 0 auto;">
                    <div>{{blog}}</div>
                    <hr>
                    <div v-html="blog"></div>
                </div>
                <script src="https://cdn.jsdelivr.net/npm/vue@2.5.16/dist/vue.min.js"></script>
                <script type="text/javascript">
                    let vm = new Vue({
                        el: '#app',
                        data () {
                            return {
                                blog : `<h2 class="align-center">一对“兄弟”</h2>
                                        <div class="align-center">
                                            <img src="http://img.hb.aicdn.com/76c310ae6a6c6166343a23821078d379367f003e2088d-xWozMi_fw658"/>

                                        </div>
                                        <p>你看他们多像一对兄弟啊，虽然是一对呆呆兔和一只傻傻猫蹲在了一起，但谁又能说他们不是兄弟呢？</p>`
                            }
                        }
                    })
                </script>
            </body>
            </html>

        文本插值中的代码被解释为节点的文本内容，而HTML插值中的代码则被解释为视图节点。实际上，HTML插值为文本插值的补充和拓展，Vue可以解析被绑定的内容为DOM节点，
        从而实现动态渲染视图的效果。不过Vue本身就支持模板，开发者在使用HTML插值的时候，应秉承以下原则：
            尽量多地使用Vue自身的模板，减少对HTML插值的使用
            只对可信内容使用HTML插值
            决不相信用户输入的数据


10. 属性绑定
    10.1 指令
        10.1.1 v-bind：DOM节点的属性基本都可以用 v-bind 进行绑定
            代码如下：
                <style>
                    .italic {font-style: italic;}
                </style>
                <div id="app" style="margin-left: 300px">
                    <p v-bind:class="className" v-bind:title="title">危险勿触</div>
                    <button v-bind:disabled="10 + 10 === 20" > 点击有奖 </button>
                    <input v-bind:type="'text'" v-bind::placeholder="true ? '输入': '请录入'"/>
                </div>

                <script src="https://cdn.jsdelivr.net/npm/vue@2.5.16/dist/vue.min.js"></script>
                <script>
                    let vm = new Vue({
                        el:'#app',
                        data () {
                            return {
                                className : 'italic',
                                title : '危险勿触'
                            }
                        }
                    })
                </script>
            当然，v-bind 也可以省略不写，代码如下：
                <div id="app" style="margin-left: 300px">
                    <p :class="className" :title="title">危险勿触</div>
                    <button :disabled="10 + 10 === 20" > 点击有奖 </button>
                    <input :type="'text'" :placeholder="true ? '输入': '请录入'"/>
                </div>
            属性也可以是绑定变量、表达式、执行函数等内容，不过最终的结果都应该满足属性自身的约束。

    10.2 类名和样式绑定
        10.2.1 类名绑定
            由于类名 class 和 样式 style 在节点属性中是两个奇怪的存在（虽然可以接收的类型都是字符串，但类名实际上是有数组拼接组成，而样式则是有对象键值对拼接而成的），
            所以Vue在绑定类名和样式时也采用不一样的机制。

            可以通过 字符串、数组和对象 三种方式为节点 动态绑定类名属性，代码如下：
                <style>
                    .color-gray {color:gray;}
                    .size-18 {font-size:18px;}
                    .style-italic {font-style:italic}

                </style>
                <div id="app">
                    <p class="color-gray size-18 style-italic">《Vue2.0 从入门到实战》，用心良苦，伴你成长</p>
                    <p :class="classStr">《Vue2.0 从入门到实战》，用心良苦，伴你成长</p>
                    <p :class="classArr">《Vue2.0 从入门到实战》，用心良苦，伴你成长</p>
                    <p :class="classObj1">《Vue2.0 从入门到实战》，用心良苦，伴你成长</p>
                    <p :class="classObj2">《Vue2.0 从入门到实战》，用心良苦，伴你成长</p>
                </div>
                <script src="https://cdn.jsdelivr.net/npm/vue@2.5.16/dist/vue.min.js"></script>
                <script>
                    let vm = new Vue({
                        el : '#app',
                        data () {
                            return {
                                classStr : 'color-gray size-18 style-italic',
                                classArr : ['color-gray','size-18','style-italic'],
                                classObj1: {'class-gray':true,'size-18':true,'style-italic':true}, // 对象，绑定类名
                                classObj2: {'class-gray':0,'size-18':'','style-italic':false}, // 对象，未绑定类名
                            }
                        }
                    })

                </script>

                在使用对象绑定类名时，应将类名作为对象键名，当键值为真时，类名将被绑定到节点上。
                真假知识点：
                    当变量值为undefined、null、0、空字符串时，判定为假，
                    除一般值外，[]、{}、-1、-0.1 也会被判定为真

        10.2.2 样式绑定
            绑定样式的方式和类名相似，但是样式是以键值对的形式，所以不能像类名一样使用数组进行绑定，代码如下：
                <div id="app">
                    <p style="color:gray; font-size:18px; font-style:italic;">《Vue2.0 从入门到实战》，用心良苦，伴你成长</p>
                    <p :style="classStr">《Vue2.0 从入门到实战》，用心良苦，伴你成长</p>
                    <p :style="classObj1">《Vue2.0 从入门到实战》，用心良苦，伴你成长</p>
                    <p :style="classObj2">《Vue2.0 从入门到实战》，用心良苦，伴你成长</p>
                </div>
                <script src="https://cdn.jsdelivr.net/npm/vue@2.5.16/dist/vue.min.js"></script>
                <script>
                    let vm = new Vue({
                        el : '#app',
                        data () {
                            return {
                                styleStr : 'color:gray; font-size:18px; font-style:italic;',
                                classObj1: {color: -1 ? 'gray' : 'black'; font-size:'18px'; font-style:'italic';}, // 对象，绑定类名
                                classObj2: {color: 0 ? 'gray' : ''; font-size:'' ? '18px' : ''; font-style:null ? 'italic' : '';}, // 对象，未绑定类名
                            }
                        }
                    })
                </script>



11. 事件绑定
    事件系统是前端开发中非常重要的内容，Vue也对其进行了封装和拓展，使之变得更加简单易用。
    11.1 指令
        v-on
            ：Vue使用 v-on 指令监听DOM事件，开发这可以将事件代码通过 v-on 指令绑定到 DOM 节点上，基本使用方法如下：

            <div id="app">
                <button v-on:click="logInfo()">打印消息（default：Hello World）</button>
                <br>
                <button v-on:click="logInfo('Self Message')">打印消息（default：Hello World）</button>
                <br>
                <button v-on:click="console.log('A Vue App')">打印消息（default：Hello World）</button>
            </div>
            <script src="https://cdn.jsdelivr.net/npm/vue@2.5.16/dist/vue.min.js"></script>
            <script>
                let vm = new Vue({
                    el: '#app',
                    methods: {
                        logInfo(msg) {
                            console.log(msg || 'Hello World')
                        }
                    }
                })
            </script>

        Vue 也为 v-on 提供了一种简写形式 @ ，代码如下：
            <button @click="logInfo()">打印消息（default：Hello World）</button>
        有时候，我们在处理事件时，也会用到事件对象本身，那么应该怎样获取事件对象本身呢？
        两种方式,代码如下：
            <div id="app">
                <!-- 1. 在事件函数不必传参数时，可以这样写，注意：不能带() -->
                <input type="text" @keyup="handleKeyUp"/>
                <!-- 2. 手动传入 $event对象 -->
                <input type="text" @keyup="handleKeyUp($event)"/>
            </div>
            <script src="https://cdn.jsdelivr.net/npm/vue@2.5.16/dist/vue.min.js"></script>
            <script>
                let vm = new Vue({
                    el: '#app',
                    methods: {
                        handleKeyUp(event) {
                            console.log(event.key,event);
                        }
                    }
                })
            </script>

    11.2 常见修饰符
        JS事件代码开发 event.preventDefault() 阻止节点默认行为
        event.stopPropagation 阻止事件冒泡，
        vue 将其 封装成简短医用的事件修饰符，可以后缀与事件名称之后

        常见的事件修饰符：

        名称          可用版本            可用事件                    说明
        .stop         所有                任意                      当事件触发时，阻止事件冒泡
        .prevent      所有                任意                      当事件触发时，阻止元素默认行为
        .capture      所有                任意                      当事件触发时，阻止事件捕获
        .self         所有                任意                      限制事件仅作用于节点自身
        .once         2.1.4以上           任意                      事件被触发一次后即解除监听
        .passive      2.3.0以上           滚动                      移动端，限制事件永不调用preventDefault()方法


        .prevent 修饰符在表单提交时的表现，先来看不使用修饰符时的情况，代码如下：
            <div id="app">
                <form @submit="handleSubmit">
                    <h2>不使用修饰符时</h2>
                    <button type="submit">提交</button>
                </form>
            </div>
            <script src="https://cdn.jsdelivr.net/npm/vue@2.5.16/dist/vue.min.js"></script>
            <script>
                let vm = new Vue({
                    el: '#app',
                    data() {
                        return {
                            counter:0
                        }
                    },
                    methods: {
                        handleSubmit() {
                            console.log(`submit $(++this.counter) times`);
                        }
                    }
                })
            </script>

        为事件添加 .prevent 修饰符，代码如下：
            <form @submit.prevent="handleSubmit">
                <h2>使用.prevent 修饰符</h2>
                <button type="submit">提交</button>
            </form>

        当事件后缀多个修饰符时，要注意修饰符的排列顺序，相应的代码会根据排列顺序依次产生。
    11.3 按键修饰符
        对于键盘事件，vue允许将按键值作为修饰符来来使用，如监听回车键

        常用按键修饰符别名
        别名修饰符                       键值修饰符                       对应按键
        .delete                         .8/.46                          辉格 / 删处
        .tab                            .9                              制表
        .enter                          .13                             回车
        .esc                            .27                             退出
        .space                          .32                             空格
        .left                           .37                             左
        .up                             .38                             上
        .right                          .39                             右
        .down                           .40                             下

        鼠标按键修饰符
        修饰符                     可用版本                        对应按键
        .left                     2.2.0以上                       左键
        .right                    2.2.0以上                       右键
        .middle                   2.2.0以上                       中键

    11.4 组合修饰符
        系统按钮修饰符

        修饰符                     可用版本                            对应按键
        .ctrl                     2.1.0以上                           Ctrl键
        .alt                      2.1.0以上                           Alt键
        .shift                    2.1.0以上                           Shift键
        .meta                     2.1.0以上                           meta键 （windows系统键盘上 win 键）

        <div id="app">
            <h1 @click.ctrl="logWithCtrl" @click="logSingle">没有ctrl别来点我</h1>
        </div>
        <script src="https://cdn.jsdelivr.net/npm/vue@2.5.16/dist/vue.min.js"></script>
        <script>
            let vm = new Vue({
                el: '#app',
                methods: {
                    logWithCtrl (event) {
                        console.log("-------------分割线-------------")
                        console.log("$event.ctrlKey:" ,event.ctrlKey)
                        console.log('按住，是的，按住 Ctrl')
                    },

                    logSingle(event) {
                        if (!event.ctrlKey) {
                            console.log("-------------分割线-------------")
                             console.log("$event.ctrlKey:" ,event.ctrlKey)
                             console.log('点我干啥，单身汪')
                        }else {
                            console.log('不错，进步很快呀!')
                        }
                    }
                }
            })
        </script>

12. 双向绑定
    指令 v-model：它负责监听用户的输入事件以更新数据

        v-model 在内部使用不同的属性为不同的输入元素并抛出不同的事件：
           1. text 和 textarea 使用 value 属性和 input 事件；
           2. checkbox 和 radio 使用 checked 属性和 change 事件；
           3. select 字段将 value 作为 prop 并将 change 作为事件。


        官方有说到，v-model的原理其实是背后有两个操作：

            1. v-bind绑定value属性的值；

            2. v-on绑定input事件监听到函数中，函数会获取最新的值赋值到绑定的属性中；


        v-model 和 v-show 时vue核心功能中内置的、开发者不可自定义的指令
        可以使用v-model为可输入元素创建双向数据绑定，它会根据元素类型自动选取正确的方法来更新元素
        代码实例如下：
            <!DOCTYPE html>
            <html lang="en">
            <head>
                <meta charset="UTF-8">
                <title>HTML插值-插值绑定</title>
                <style>
                    .align-center {
                        text-align: center;
                    }
                </style>
            </head>
            <body>
            <div id="app" style="width: 800px;margin: 0 auto;">
                <h3>单行文本框</h3>
                <input type="text" v-model="singleText" style="width: 240px;"/>
                <p>{{ singleText }}</p>
                <h3>多行文本框</h3>
                <textarea v-model="multiText" style="width: 240px;"></textarea>
                <pre>{{ multiText }}</pre>

                <h3>单选框</h3>
                <!--
                    由于点击被选中的单选项无法取消其被选中的状态，所以实战中一般没有使用单个但选项的场景。
                    这里，设置 v-model 共用同一个变量 可实现 RadioGroup 的效果
                -->
                <input type="radio" id="ra" value="杨玉环" v-model="radioValue">
                <label for="ra">A.杨玉环</label>
                <input type="radio" id="rb" value="赵飞燕" v-model="radioValue">
                <label for="rb">B.赵飞燕</label>
                <p>{{ radioValue }}</p>

                <h3>单个复选框</h3>
                <!--
                    单个复选框被用于true 和 false 的切换
                -->
                <input id="c" type="checkbox" v-model="toggleValue"/>
                <label for="c">天生丽质</label>
                <p>{{ toggleValue }}</p>

                <h3>多个复选框</h3>
                <!--
                    v-model 接收数组类型变量
                -->
                <input id="ca" type="checkbox" value="漂亮" v-model="checkedValues"/>
                <label for="ca">A.回眸一笑百媚生</label>
                <input id="cb" type="checkbox" value="瘦弱" v-model="checkedValues"/>
                <label for="cb">B.体轻能为掌上舞</label>
                <input id="cc" type="checkbox" value="得宠" v-model="checkedValues"/>
                <label for="cc">C.三千宠爱在一身</label>
                <p>{{ checkedValues.join(',') }}</p>
            </div>
            <script src="https://cdn.jsdelivr.net/npm/vue@2.5.16/dist/vue.min.js"></script>
            <script type="text/javascript">
                let vm = new Vue({
                    el: '#app',
                    data() {
                        return {
                            singleText: '',
                            multiText: '',
                            radioValue: '',
                            toggleValue: '',
                            checkedValues: []
                        }
                    }
                })
            </script>
            </body>
            </html>

        下拉框也可以使用v-model进行双向绑定。代码如下：
            <!DOCTYPE html>
            <html lang="en">
            <head>
                <meta charset="UTF-8">
                <title>HTML插值-插值绑定</title>
                <style>
                    .align-center {
                        text-align: center;
                    }
                </style>
            </head>
            <body>
            <div id="app" style="width: 800px;margin: 0 auto;">
                <h3>下拉框</h3>
                <select v-model="singleSelect">
                    <option value="汉代">汉代</option>
                </select>
                <p>{{singleSelect}}</p>

                <select multiple v-model="multiSelect">
                    <option value="汉代">汉代</option>
                    <option value="汉代">汉代</option>
                    <option value="汉代">汉代</option>
                    <option value="汉代">汉代</option>
                </select>
                <p>{{multiSelect.join(",")}}</p>
            </div>
            <script src="https://cdn.jsdelivr.net/npm/vue@2.5.16/dist/vue.min.js"></script>
            <script type="text/javascript">
                let vm = new Vue({
                    el: '#app',
                    data() {
                        return {
                            singleSelect: '唐代', // 设置默认值
                            multiSelect: [1,3]
                        }
                    }
                })
            </script>
            </body>
            </html>


    12.2 v-model 与 修饰符

        修饰符                         可用版本                    说明
        .lazy                           所有                      将用户输入的数据赋值于变量的时机由输入时延迟到数据改变时
        .number                         所有                      自动转换用户输入为数值类型
        .trim                           所有                      自动过滤用户输入的首尾空白字符


        代码实例如下：
            <!DOCTYPE html>
            <html lang="en">
            <head>
                <meta charset="UTF-8">
                <title>HTML插值-插值绑定</title>
                <style>
                    .align-center {
                        text-align: center;
                    }
                </style>
            </head>
            <body>
            <div id="app" style="width: 800px;margin: 0 auto;">
                <input type="text" v-model.trim.number="text" @keyup="handleKeyUp"/>
            </div>
            <script src="https://cdn.jsdelivr.net/npm/vue@2.5.16/dist/vue.min.js"></script>
            <script type="text/javascript">
                let vm = new Vue({
                    el: '#app',
                    data: () => (
                        {
                            text : ''
                        }
                    ),
                    methods:{
                        handleKeyUp() {
                            console.log(this.text,typeof this.text);
                        }
                    }

                })
            </script>
            </body>
            </html>

    12.3 v-model 与 自定义组件
        代码实例如下：
            <!DOCTYPE html>
            <html lang="en">
            <head>
                <meta charset="UTF-8">
                <title>HTML插值-插值绑定</title>
                <style>
                    .align-center {
                        text-align: center;
                    }
                </style>
            </head>
            <body>
            <div id="app" style="width: 800px;margin: 0 auto;">
                <!-- 自定义组件 -->
                <custom-screen v-model="text"></custom-screen>
                <!-- 原生元素  -->
                <input type="text" id="it" v-model.trim.number="text"/>
            </div>
            <script src="https://cdn.jsdelivr.net/npm/vue@2.5.16/dist/vue.min.js"></script>
            <script type="text/javascript">

                Vue.component(
                    'custom-screen',
                    {
                        props: ['value'],
                        methods: {
                            handleReset() {
                                console.log("重置为\'\'");
                                this.$emit('input','') ; // 使用 $emit 发送 input 事件，并将目标值作为 参数传出
                            }
                        },
                        template: `<div>
                          <h2>输入值为： {{value}}</h2>
                          <button @click="handleReset">重置为空</button>
                        </div>
                        `
                    }
                )

                let vm = new Vue({
                    el: '#app',
                    data: () => (
                        {
                            text : ''
                        }
                    )
                })
            </script>
            </body>
            </html>
        在自定义组件中，value属性和input事件尤为重要，他们分别负责不同方向的数据传递。value属性用于接收外部传入的值以更新组件内部的状态，
        input事件由开发者决定在什么时候调用，并负责将组件内部的状态同步到外部。


        但是像单选框、复选框等类型的输入控件可能会将 value attribute 用于不同的目的。model 选项可以用来避免这样的冲突：

            Vue.component('base-checkbox', {
              model: {
                prop: 'checked',
                event: 'change'
              },
              props: {
                checked: Boolean
              },
              template: `
                <input
                  type="checkbox"
                  v-bind:checked="checked"
                  v-on:change="$emit('change', $event.target.checked)"
                >
              `
            })
        现在在这个组件上使用 v-model 的时候：这里的 lovingVue 的值将会传入这个名为 checked 的 prop。
        同时当 <base-checkbox> 触发一个 change 事件并附带一个新的值的时候，这个 lovingVue 的 property 将会被更新。




13. 条件渲染和列表渲染
    13.1 条件渲染
        13.1.1 指令 v-if
            只需要为元素挂上 v-if 指令即可，与之配套的还有 v-else 和 v-else-if，不过，它们只能与 v-if 配合使用。
            代码实例如下：
                <!DOCTYPE html>
                <html lang="en">
                <head>
                    <meta charset="UTF-8">
                    <title>HTML插值-插值绑定</title>
                    <style>
                        .align-center {
                            text-align: center;
                        }
                    </style>
                </head>
                <body>
                <div id="app" style="width: 800px;margin: 0 auto;">
                    <h2 v-if="order === 0">站在前排 v-if</h2>
                    <h2 v-else-if="order === 1">不上不下 v-else-if</h2>
                    <h2 v-else>负责垫后的 v-else</h2>

                    <button @click="toggleTitle">切换标题 </button>
                </div>
                <script src="https://cdn.jsdelivr.net/npm/vue@2.5.16/dist/vue.min.js"></script>
                <script type="text/javascript">
                    let vm = new Vue({
                        el: '#app',
                        data () {
                            return {
                                order : 0
                            }
                        },
                        methods:{
                            toggleTitle() {
                                this.order  = ++this.order % 3;
                                console.log("order 的 值：",this.order);
                            }
                        }
                    })
                </script>
                </body>
                </html>

        13.1.2 指令 v-show
            v-show 可以用于实现条件渲染，不过它只是简单地切换元素的CSS属性：display。当条件判断为假时，元素的display属性将被赋予为none，反之，元素的display属性将恢复为原有值
            相对于 v-if 来说，v-show 并不算作真正的条件渲染，因为 挂载它的多个元素之间没有上下文关系。
            代码实例如下：
                <!DOCTYPE html>
                <html lang="en">
                <head>
                    <meta charset="UTF-8">
                    <title>HTML插值-插值绑定</title>
                    <style>
                        .align-center {
                            text-align: center;
                        }
                    </style>
                </head>
                <body>
                <div id="app" style="width: 800px;margin: 0 auto;">
                    <h2 v-show="visible">v-show , visible = true</h2>
                    <h2 v-show="!visible">v-show , visible = false</h2>
                    <h2 v-if="visible">v-if , visible = true</h2>
                    <h2 v-else>v-else , visible = false</h2>
                </div>
                <script src="https://cdn.jsdelivr.net/npm/vue@2.5.16/dist/vue.min.js"></script>
                <script type="text/javascript">
                    let vm = new Vue({
                        el: '#app',
                        data () {
                            return {
                                visible : false
                            }
                        }
                    })
                </script>
                </body>
                </html>

            注意：
                1. v-if 会在切换中将组件上的事件监听器和子组件销毁和重建。当组件被销毁时，它将无法被任何方式获取，因为它已不存在于DOM中
                2. 在创建父组件时，如果子组件的 v-if 被判定为假，vue 不会对子组件做任何事情，直到第一次判定为真时。这在使用vue生命周期钩子函数时尤为重要，
                    如果生命周期已走过组件创建的阶段，却仍然无法获取组件对象，想一想，是不是 v-if 在作怪
                3. v-show 有更高的初始渲染开销，而 v-if 有更高的切换开销，这与它们的实现机制有关，在使用时要多加考虑具体的应用场景
                4. v-show 不支持 template 元素，不过在 vue2.0 中，template 的应用 并不广泛

    13.2 列表渲染
        13.2.1 指令 v-for
            v-for 用于 实现列表渲染，可以使用 item in items 或者 item of items 的语法，代码如下：
                <!DOCTYPE html>
                <html lang="en">
                <head>
                    <meta charset="UTF-8">
                    <title>HTML插值-插值绑定</title>
                    <style>
                        .align-center {
                            text-align: center;
                        }
                    </style>
                </head>
                <body>
                <div id="app" style="width: 800px;margin: 0 auto;">
                    <div style="float: left;width: 160px;">
                        <h2>用户列表</h2>
                        <ul>
                            <!-- index 作为第二个参数，用以标识下标 -->
                            <li v-for="(item ,index) in users" >{{index}}.&nbsp;{{item.name}}</li>
                        </ul>
                    </div>

                    <div style="margin-left: 170px; overflow: hidden">
                        <h2>用户列表</h2>
                        <ul>
                            <li v-for="(user,uIndex) of users">{{uIndex}}.&nbsp;{{user.name}}</li>
                        </ul>
                    </div>
                </div>
                <script src="https://cdn.jsdelivr.net/npm/vue@2.5.16/dist/vue.min.js"></script>
                <script type="text/javascript">
                    let vm = new Vue({
                        el: '#app',
                        data () {
                            return {
                                users : [
                                    {name:'Clark',age:27,city:'Chicago'},
                                    {name:'Jackson',age:28,city:'Sydney'}
                                ]
                            }
                        }
                    })
                </script>
                </body>
                </html>

            除了能渲染数组外，还可以渲染一个对象的键值对,代码如下：
                <!DOCTYPE html>
                <html lang="en">
                <head>
                    <meta charset="UTF-8">
                    <title>HTML插值-插值绑定</title>
                    <style>
                        .align-center {
                            text-align: center;
                        }
                    </style>
                </head>
                <body>
                <div id="app" style="width: 800px;margin: 0 auto;">
                    <div style="float: left;width: 160px;">
                        <h2>用户列表</h2>
                        <ul>
                            <!-- index 作为第二个参数，用以标识下标 -->
                            <li v-for="(user ,index) in users">
                                用户 {{ index + 1 }}
                                <ul>
                                    <li v-for="(value ,key) of user">{{ key }}：&nbsp;{{ value }}</li>
                                </ul>
                            </li>
                        </ul>
                    </div>
                </div>
                <script src="https://cdn.jsdelivr.net/npm/vue@2.5.16/dist/vue.min.js"></script>
                <script type="text/javascript">
                    let vm = new Vue({
                        el: '#app',
                        data() {
                            return {
                                users: [
                                    {name: 'Clark', age: 27, city: 'Chicago'},
                                    {name: 'Jackson', age: 28, city: 'Sydney'}
                                ]
                            }
                        }
                    })
                </script>
                </body>
                </html>

            Vue 会把数组当作被观察者 加入响应式系统中，当调用一些方法修改数组时，对应的视图将会同步更新。
            与数据响应有关的数组方法:
                名称              说明
                push                将一个或多个元素添加至数组末尾，并返回新数组的长度
                pop                 从数组中删除并返回最后一个元素
                shift               从数组中删除并返回第一个元素
                unshift             将一个或多个元素添加至数组开头，并返回新数组的长度
                splice              从数组中删除元素或向数组添加元素
                sort                对数组元素排序，默认按照Unicode编码排序，返回排序后的数组
                reverse             将数组中的元素位置颠倒，返回颠倒后的数组

            代码实例如下：
                <!DOCTYPE html>
                <html lang="en">
                <head>
                    <meta charset="UTF-8">
                    <title>HTML插值-插值绑定</title>
                    <style>
                        .align-center {
                            text-align: center;
                        }
                    </style>
                </head>
                <body>
                <div id="app" style="width: 800px;margin: 0 auto;">
                    <div style="float: left;width: 160px;">
                        <h2>用户列表</h2>
                        <button @click="createUser">创建用户</button>
                        <button @click="reverse">倒序数组</button>
                        <ul>
                            <!-- index 作为第二个参数，用以标识下标 -->
                            <li v-for="(user ,index) in users">
                                用户 {{ index + 1 }}
                                <ul>
                                    <li v-for="(value ,key) of user">
                                        <strong style="display: inline-block;width: 60px;">{{key}}:</strong>
                                        <span>{{value}}</span>
                                    </li>
                                </ul>
                            </li>
                        </ul>
                    </div>
                </div>
                <script src="https://cdn.jsdelivr.net/npm/vue@2.5.16/dist/vue.min.js"></script>
                <script type="text/javascript">
                    let vm = new Vue({
                        el: '#app',
                        data() {
                            return {
                                users: []
                            }
                        },
                        methods:{
                            random(factor,base) { // 根据乘积因子和基数生成随机整数
                                return Math.floor(Math.random() * (factor || 1)) + (base || 0)
                            },
                            createUser() {
                                // 获取name 大写首字母
                                let fLetter = 'BJHK'[this.random(3.999)];
                                // 随机截取 name 字符串
                                let nameStr = 'abcdefghijklmnopqrstuvwxyz';
                                let bLetter = nameStr.substr(this.random(3.999), this.random(3.999, 3));
                                let user = {
                                    name: fLetter + bLetter,
                                    age: this.random(5.999, 25),
                                    city: ['Chicago', 'Sydney', 'Shenzhen', 'Hangzhou'][this.random(3.999)]
                                }

                                console.log("=======================创建用户========================\n", user);
                                this.users.push(user);
                            },
                            reverse() {
                                console.log("=======================倒序列表=============================")
                                console.log('Before',this.users.map(user => user.name));
                                this.users.reverse();
                                console.log('After',this.users.map(user => user.name));

                            }
                        }
                    })
                </script>
                </body>
                </html>

            要注意：
                直接使用 下标/键名为数组/对象设置成员时，有以下用法：
                    arr[0] = 99  // 使用索引为数组设置成员
                    obj['key'] = 'value' // 使用键名为对象设置成员
                Vue并不会将其加入数据响应式系统，因此当数据被修改时，视图不会进行更新。

        13.2.2 列表渲染中的key
            在使用 v-for时，最好为每个迭代元素提供一个值不重复的key
            当列表渲染被重新执行时，如果不使用key，vue 会为数组成员就近复用已存在的DOM节点，如下所示：

                数组成员1       DOM节点1                                                  数组成员3                           DOM节点1

                数组成员2       DOM节点2       --->       当数组发生变化时    --->          数组成员1                           DOM节点2

                数组成员3       DOM节点3                                                  数组成员2                           DOM节点3

            当使用key时，Vue会根据key的变化重新排列节点顺序，并移除key不存在的节点
                数组成员1       DOM节点1                                                  数组成员3                           DOM节点3

                数组成员2       DOM节点2       --->       当数组发生变化时    --->          数组成员1                           DOM节点1

                数组成员3       DOM节点3                                                  数组成员2                           DOM节点2


            实质上，key 的存在是为DOM节点标注了一个身份信息，让Vue能够有迹可循追踪到数据对应的节点。在实战开发中，是否使用key都不会影响功能的实现。

14. 选项
    14.1 数据选项
        数据（data）选项可接收的类型有对象和函数两种，
        定义一个组件时，数据选项只能接收函数类型。
        代码实例如下：
            <!DOCTYPE html>
            <html lang="en">
            <head>
                <meta charset="UTF-8">
                <title>HTML插值-插值绑定</title>
                <style>
                    .align-center {
                        text-align: center;
                    }
                </style>
            </head>
            <body>
            <div id="app" style="width: 800px;margin: 0 auto;">
                <h1>{{title}}</h1>
                <button-counter></button-counter>
            </div>
            <script src="https://cdn.jsdelivr.net/npm/vue@2.5.16/dist/vue.min.js"></script>
            <script type="text/javascript">
                Vue.component('button-counter',{
                    data () {
                        return {
                            counter: 1
                        }
                    },
                    template : '<button @click="counter++">clicked {{counter}} times</button>'
                })


                // let vm = new Vue({
                //     el : '#app',  // mount 到 DOM 上
                //     data : {  // 对象类型
                //         title: 'A Vue App'
                //     }
                // })

                let vm = new Vue({
                    el : '#app', // mount 到 DOM 上
                    data() {   //函数类型
                        return {
                            title:'A Vue App'
                        }
                    }
                })
            </script>
            </body>
            </html>

        在vue中声明组件时，如果使用了对象类型的data选项，模板将找不到在data中声明的数据。如果使用了支持vue模板的语法检察权，开发者将得到错误提示 ‘data property in component must be a function’


        Vue 会递归地将data选项中的数据加入响应式系统，但这些数据应该是声明的时候即存在的。下面 来看一段代码 （单文件组件模板）:
            <template>
                <div>
                    <h2>{{title}}</h2>
                    <p>{{profile}}</p>
                </div>
            </template>

            <script>
                export default{
                    name:'Instance',
                    data () {
                        return {
                            title : 'A Vue App'
                        }
                    },
                    created () {
                        Object.assign(this.$data,{  // 为对象赋值属性，没有则添加属性，有则覆盖原有的属性值
                            profile : 'This is a Vue App'
                        })

                        console.log(this.$data)
                    }
                }
            </script>

        title 是在初始化实例时声明在data选项中的数据，而profile则是在created钩子函数中被赋予data选项的。可以看出，profile被赋予data选项后，视图没有发生任何变化，这是因为
        vue在处理数据时，并未把profile加入数据响应式系统。又因为 profile 是在实例创建完成后被绑定到组件上的，所以vue给出了错误提示 ‘profile is not defined’。
        此时的profile 只是一个普通js属性，而非被vue观察的对象。

        在实际开发中，应将可能在实例中被观察的对象预先在data选项中声明，以任何浏览器所支持的原生api 都无法将数据动态加入响应式系统，不过vue针对这一需求，也提供了响应的机制。
        开发者可以使用 $set 方法 为 data 选项动态绑定数据，但其也无法挂载响应数据到data根节点。不过，既然这些数据要绑定到 $data 根节点上，何不在初始化时声明呢？

        $set 用法如下：
            /**
             * target 目标对象     Object | Array
             * key    键名         String | Number
             * value 键值          任意类型
             */
             // Vue.set(target,key,value)
             created () {
                this.$set(target,key,value)
             }

        下面将分别演示使用原生方法 Object.assign 和 Vue.$set为组件挂载响应式数据的实例
        关于 Object.assign的代码如下：
            <template>
                <div>
                    <h2>{{title}}</h2>
                    <p>{{obj.profile}}</p>
                    <button @click="toggle">toggle</button>
                </div>
            </template>
            <script>
                export default {
                    name : 'instance',
                    data () {
                        return {
                            title : 'A Vue App',
                            obj : {}  // $set 不能用在根节点 data 上
                        }
                    },

                    created () {
                        Object.assign(this.obj,{
                            profile : 'This is a Vue App'
                        })

                        console.log('created',this.obj)
                    },

                    mounted () {
                         Object.assign(this.obj,{
                            profile : 'This is a Vue Test App'
                        })

                        console.log('created',this.obj)
                    },

                    methods : {
                        toggle () {
                            Object.assign(this.obj,{
                                profile : 'This is a Vue App for test'
                            })

                            console.log('toggle',this.obj)
                        }
                    }

                }
            </script>

        相比之前使用 Object.assign 的示例，这次的视图表现更显奇怪，vue不仅没有提示错误，还响应了在 created 钩子函数 中所做的修改，从
        生命周期角度分析：
            1. 在组件实例被创建式 （beforeCreate 和 create 之间）时，obj对象作为 data选项的属性存在与实例中，且拥有合法的地址
            2. 在created 钩子函数中，将profile挂载在obj对象上，obj.profile 由undefined 变为 被赋予的值。由于 obj.profile 被赋值时，实例
                已经过了将数据加入响应式系统的阶段，所以 ob.profile 并未被观察。又因为实例尚未和Dom节点绑定（beforeMount
                ），所以此时修改 profile 依然可以影响之后的视图表现（profile的视图表现是在实例created时被赋予的）。
            3. 在mounted钩子函数和click事件中，由于实例已经绑定到DOM节点上且profile不存在于响应式系统中，所以此时修改profile，视图没有发生变化。

        将代码稍作修改，在created中以 $set 的方式为对象绑定属性，代码如下：
            created () {
                this.$set(this.obj,'profile','This is a Vue App'
                console.log('created',this.obj)
            }
        此时的profile被加入vue 的响应式系统，当笔者点击按钮时，视图也发生了变化，
        需要注意的是：不要将已有内存地址的对象用于data选项，我们应该创建新对象。

        已有内存地址的代码如下：
            <div id="app">
                <button-counter></button-counter>
                <button-counter></button-counter>
            </div>
            <script src="https://cdn.jsdelivr.net/npm/vue@2.5.16/dist/vue.min.js"></script>
            <script>
                let jack = {counter:0};
                Vue.component('button-counter',{
                    data () {
                        return jack;
                    },
                    template : '<button @click="counter++">click {{{counter}} </button>'
                })

                let vm = new Vue({
                    el: '#app'

                });
            </script>

        使用创建新的对象：
             <div id="app">
                <button-counter></button-counter>
                <button-counter></button-counter>
            </div>
            <script src="https://cdn.jsdelivr.net/npm/vue@2.5.16/dist/vue.min.js"></script>
            <script>

                Vue.component('button-counter',{
                    data () {
                        return {
                            counter: 0
                        }


                    },
                    template : '<button @click="counter++">click {{{counter}} </button>'
                })

                let vm = new Vue({
                    el: '#app'

                });
            </script>

            或者使用 JSON.parse(JSON.stringify(obj))深拷贝已有对象
                <div id="app">
                    <button-counter></button-counter>
                    <button-counter></button-counter>
                </div>
                <script src="https://cdn.jsdelivr.net/npm/vue@2.5.16/dist/vue.min.js"></script>
                <script>
                    let jack = {counter:0};
                    Vue.component('button-counter',{
                        data () {
                            return JSON.parse(JSON.stringify(jack));
                        },
                        template : '<button @click="counter++">click {{{counter}} </button>'
                    })

                    let vm = new Vue({
                        el: '#app'

                    });
                </script>

            以上两种方式，目的都是为实例的data选项分配一个新的内存地址.

    14.2 属性选项
        Vue 为组件开发提供了 属性【props】 选项，我们可以使用它为组件注册动态特性，处理业务间的差异，使代码可以复用于相似的应用场景。

        props 选项可以是数组或者对象类型，用于接收从 父组件 传递过来的参数，并允许开发者为其设置默认值，类型检测和校验规则等。
        代码如下：
            <div id="app">
                <color-text text="Hello World"></color-text>
                <br>
                <color-text></color-text>
                <br>
                <color-text color="#f78" text="Hello World"></color-text>
                <br>
                <color-text color="#43dt" text="Hello World"></color-text>
            </div>
            <script src="https://cdn.jsdelivr.net/npm/vue@2.5.16/dist/vue.min.js"></script>
            <script>
                Vue.component('color-text',{
                    props:{
                        text: String,
                        color : {
                            type:String,
                            default:'#000',
                            required:true,
                            validator () {
                                return /^([0-9a-fA-F]{6}|[0-9a-fA-F]{3})$/.test(value);
                            }
                        }
                    },
                    template : '<span :style="{color:color}">{{text}}</span>'
                })

                let vm = new Vue({
                    el:'#app'
                })
            </script>

    14.3 方法选项
        代码1：
            let store1 = {
                msg : 'Hello World',
                logMSG () {
                    console.log("=================匿名函数=========================")
                    console.log(this.msg)
                }
            }

            store1.logMsg();

        代码2：
            let store2 = {
                msg : 'Hello World',
                logMSG : () => {
                    console.log("=================箭头函数=========================")
                    console.log(this.msg)
                }
            }

            store2.logMsg();

        使用 箭头函数 定义方法时并不会创建函数作用域，因此 this 也不会指向其父级实例，此时的this会向上追踪，当找到某本函数作用域时，this将指向该函数的父级实例；
        否则，this将指向浏览器的内置对象 window

        methods 选项 不能使用箭头函数 在其中定义方法。在创建组件时，methods中的方法将被绑定到vue实例上，方法中的this也将自动指向vue实例。

    14.4 计算属性
        计算属性 computed 选项 设计的初衷在于减轻模板上的业务负担，当数据链上出现复杂的衍生数据时，期望以一种易维护的方式使用它
        下面示例没有使用 computed 属性的场景：
            <!DOCTYPE html>
            <html lang="en">
            <head>
                <meta charset="UTF-8">
                <title>计算属性</title>
            </head>
            <body>
            <div id="app" style="font-family: Roboto,sans-serif; color : rgb(84.92.100);margin-left: 100px;">
                <h2>英语中的“互文”</h2>
                <p>我们先来看三句话 (代码)：</p>
                <p>{{message}}.&nbsp;&nbsp;我看到的是车还是猫。</p>
                <p>{{message.replace(/\s/g,'')}}</p>
                <p>{{message.replace(/\s/g,'').split('').reverse().join('')}}</p>
                <p>英语中也有“互文”的修辞手法，比如{{message}}这句话</p>
                <p>将句中空格去掉可得 {{message.replace(/\s/g,'')}},</p>
                <p>将句中空格去掉并将其倒序可得 {{message.replace(/\s/g,'').split('').reverse().join('')}}.</p>
                <p>可以看到，{{message.replace(/\s/g,'')}} = {{message.replace(/\s/g,'').split('').reverse().join('')}}，</p>
                <p>这是互文英语的一个示例</p>
            </div>
            <script src="https://cdn.jsdelivr.net/npm/vue@2.5.16/dist/vue.min.js"></script>
            <script type="text/javascript">

                let vm = new Vue({
                    el : '#app', // mount 到 DOM 上
                    data() {   //函数类型
                        return {
                            message : 'WAS IT A CAR OR A CAT I SAW'
                        }
                    }
                })
            </script>
            </body>
            </html>

        基于 computed 选项 重构的示例：
            <!DOCTYPE html>
            <html lang="en">
            <head>
                <meta charset="UTF-8">
                <title>计算属性</title>
            </head>
            <body>
            <div id="app" style="font-family: Roboto,sans-serif; color : rgb(84.92.100);margin-left: 100px;">
                <h2>英语中的“互文”</h2>
                <p>我们先来看三句话 (代码)：</p>
                <p>{{message}}.&nbsp;&nbsp;我看到的是车还是猫。</p>
                <p>{{noSpaceMsg}}</p>
                <p>{{palindromeMsg}}</p>
                <p>英语中也有“互文”的修辞手法，比如{{message}}这句话</p>
                <p>将句中空格去掉可得 {{noSpaceMsg}},</p>
                <p>将句中空格去掉并将其倒序可得 {{palindromeMsg}}.</p>
                <p>可以看到，{{noSpaceMsg}} = {{palindromeMsg}}，</p>
                <p>这是互文英语的一个示例</p>
            </div>
            <script src="https://cdn.jsdelivr.net/npm/vue@2.5.16/dist/vue.min.js"></script>
            <script type="text/javascript">

                let vm = new Vue({
                    el : '#app', // mount 到 DOM 上
                    data() {   //函数类型
                        return {
                            message : 'WAS IT A CAR OR A CAT I SAW'
                        }
                    },
                    computed : {
                        noSpaceMsg() {
                            return this.message.replace(/\s/g,'')
                        },
                        palindromeMsg() {
                            return this.message.replace(/\s/g,'').split('').reverse().join('');
                        }
                    }
                })
            </script>
            </body>
            </html>

        与methods 一样，computed 不能以箭头函数声明，同时 它也会被混入 vue示例，并可通过this调用。
        由于 计算属性 依赖于 响应式属性，所以当且仅当 响应式属性变化时，计算属性才会被重新计算，而且得到的结果将会被缓存，一直到响应式属性再次被修改时。
        相比于methods函数求值，这是一种更为高效的机制。

        vue允许开发者为computed属性赋值
        开发者有权定义可被赋值的computed属性，方法类似于定义对象属性描述符中的setter和getter。示例代码如下：
            <!DOCTYPE html>
            <html lang="en">
            <head>
                <meta charset="UTF-8">
                <title>计算属性</title>
            </head>
            <body>
            <div id="app">
                <h2>数据变化之前
                    <i style="color:#ababab;font-size: 14px;">
                        * 指令 v-once 可以限制 视图不再响应数据变化
                    </i>
                </h2>
                <p v-once>{{message}}</p>
                <p v-once>{{noSpaceMsg}}</p>
                <h2>数据变化之后</h2>
                <p>{{message}}</p>
                <p>{{noSpaceMsg}}</p>
            </div>
            <script src="https://cdn.jsdelivr.net/npm/vue@2.5.16/dist/vue.min.js"></script>
            <script type="text/javascript">

                let vm = new Vue({
                    el : '#app', // mount 到 DOM 上
                    data() {   //函数类型
                        return {
                            message : 'WAS IT A CAR OR A CAT I SAW'
                        }
                    },
                    computed : {
                        noSpaceMsg : {
                            set (value) {
                                this.message = value;
                            },

                            get () {
                                return this.message.replace(/\s/g,'');
                            }
                        }
                    }
                })
            </script>
            </body>
            </html>

    14.5 侦听属性
        Vue 允许开发者使用侦听属性（watch选项）为实例添加被观察对象，并在对象被修改时调用开发自定义的方法。
        代码如下：
            <!DOCTYPE html>
            <html lang="en">
            <head>
                <meta charset="UTF-8">
                <title>计算属性</title>
            </head>
            <body>
            <div id="app">
                <h2>数据变化之前
                    <i style="color:#ababab;font-size: 14px;">
                        * 指令 v-once 可以限制 视图不再响应数据变化
                    </i>
                </h2>
                <p v-once>{{message}}</p>
                <p v-once>{{noSpaceMsg}}</p>
                <h2>数据变化之后</h2>
                <p>{{message}}</p>
                <p>{{noSpaceMsg}}</p>
            </div>
            <script src="https://cdn.jsdelivr.net/npm/vue@2.5.16/dist/vue.min.js"></script>
            <script type="text/javascript">

                let vm = new Vue({
                    el : '#app', // mount 到 DOM 上
                    data() {   //函数类型
                        return {
                            message : 'WAS IT A CAR OR A CAT I SAW',
                            noSpaceMsg : 'WASITACARORACATISAW'
                        }
                    },
                    watch : { // 使用watch实现，当元数据变化时，同步衍生数据的状态
                        message (newValue,oldValue) {  // message: 表示被观测的对象属性，如 data选项中的 message,事实证明，有没有参数都一样可以实现
                            this.noSpaceMsg = this.message.replace(/\s/g,'');
                        }
                    }
                })
            </script>
            </body>
            </html>
        由于 watch 更注重于处理数据变化时的业务逻辑，而computed 更注重于衍生数据，因此，与 computed 相比，watch 还优于 可以异步修改数据。
        代码如下：
            import axios from 'axios'
            let vm = new Vue({
                el : '#app',
                data () {
                    return {
                        message : '书山有路勤为径，学海无涯苦作舟',
                        remoteMsg: ''
                    }
                },
                watch : {
                    message(newValue,oldValue ){
                        axios ({
                            method:'GET',
                            url: '/someurl',
                            params: {
                                message : newValue
                            }
                        }).then(res => {
                            this.remoteMsg = res.data.message; // 接收响应后，异步修改数据
                        })
                    }
                }
            })

        vue 还为watch提供了丰富的声明方式，代码如下：
            let vm = new Vue({
                el:'#app',
                data() {
                    return {
                        msg: {
                            sender:'Jack',
                            receiver: 'Rose'
                        }
                    }
                },
                methods: {
                    logLine() {
                        console.log("===========================分割线============================")
                    },
                    logMsg(newValue,oldValue) {
                        console.log(newValue)
                    }
                },
                watch: {
                    msg :{
                        handler : 'logMsg',
                        deep: true, // 深度冠词，对象任何层级数据发生变化，watch方法都会被触发
                        immediate : true // 立即调用： 在侦听开始时立即调用一次watch方法
                    },
                    'msg.sender':['logLine','logMsg'] // 数组方式，可以调用多个方法
                }
            })


    14.6 DOM渲染
        14.6.1 指定被挂载元素
            el 选项 可用于指定 vue实例的挂载目标，属性值仅限于 CSS 选择器 或者DOM节点对象
            代码如下：
                <style>
                    .fixed-width {
                        display:inline-block;
                        width: 100px;
                    }
                </style>
                <p id="app"><strong class="fixed-width">CSS选择器：</strong>{{ msg }}</p>
                <p id="app2"><strong class="fixed-width">DOM节点：</strong>{{ msg }}</p>
                <p id="app3"><strong class="fixed-width">手动挂载：</strong>{{ msg }}</p>
                <button onclick="handleMount()">手动挂载</button>
                <script src="https://cdn.jsdelivr.net/npm/vue@2.5.16/dist/vue.min.js"></script>
                <script>
                    let vm = new Vue({
                        el:'#app',
                        data() {
                            return {
                                msg : 'Hello World'
                            }
                        }
                    })

                    let vm2 = new Vue({
                        el: document.getElementById('app2'),
                        data() {
                            return {
                                msg : 'Hello World'
                            }
                        }
                    })

                    let vm3 = new Vue({

                        data() {
                            return {
                                msg : 'Hello World'
                            }
                        }
                    })

                    let handleMount = function() {
                        vm3.$mount("#app3");
                    }
                </script>

            上述三种方式得到的结果都一样

        14.6.2  视图的字符串模板
            Vue 允许开发者使用字符串作为实例的模板，模板字符串有 template 选项接收，示例代码如下：
                <div id="app">target element</div>
                <script src="https://cdn.jsdelivr.net/npm/vue@2.5.16/dist/vue.min.js"></script>
                <script>
                    let vm = new Vue({
                        el:'#app',
                        template : '<h1>template element</h1>'   // 模板节点将替换原有的DOM节点
                    })
                </script>

        14.6.3 渲染 函数 render
            render 函数同样也可以用于渲染视图，它提供了回调方法 createElement 以供我们创建 DOM节点。
            代码如下：
                <!DOCTYPE html>
                <html lang="en">
                <head>
                    <meta charset="UTF-8">
                    <title>渲染函数 render</title>
                    <style>
                        .btn {
                            outline: none;
                            border: none;
                            cursor: pointer;
                            padding: 5px 12px;
                        }

                        .btn-text {
                            color: #409eff;
                            background-color: transparent;
                        }

                        .btn-text:hover {
                            color: #66b1ff
                        }
                    </style>
                </head>
                <body>
                <div id="app">
                    <fly-table :fields="fields" :goods="goods">
                        <span slot="title">Fly Table COmponent</span>
                    </fly-table>
                </div>

                <script src="https://cdn.jsdelivr.net/npm/vue@2.5.16/dist/vue.min.js"></script>
                <script type="text/javascript">
                    Vue.component('fly-table', {
                        props: {
                            fields: {
                                type: Array,
                                default() {
                                    return [];
                                }
                            },
                            goods: {
                                type: Array,
                                default() {
                                    return [];
                                }
                            }
                        },
                        methods: {
                            reverse() {
                                this.goods.reverse();
                            }
                        },

                        /**
                         * -render函数
                         * -参数：createElement函数
                         * -返回值：必须返回一个createElement函数的调用结果，也就是模版内的顶层元素（这个方法在vue2的习惯性使用中经常用h来命名）
                         */
                        render(createElement) {

                            /**
                             * -createdElement 的三个参数
                             * 1. HTML 标签字符串 （String） | 组件选项对象 （Object） | 节点解析函数 （Function）
                             * 2. 定义节点特性的对象 （Object）
                             * 3. 子节点，createElement 构建的 VNode 节点 或字符串生成的无标签文本节点 （Array | String）
                             */
                            return createElement('div', {
                                // 作为子组件时的插槽名称
                                slot: 'fly-table'
                            }, [
                                createElement('h2', this.$slots.title),
                                createElement('button', {
                                    // clas 用于绑定类名，同 v-bind:class 的绑定方式
                                    class: ['btn', 'btn-text'],
                                    // attrs 用于绑定节点一般属性，如 id、disabled、title 等
                                    attrs: {
                                        disabled: false,
                                        title: '点击是数组倒序'
                                    },
                                    // domProps 用于绑定节点DOM属性 如 innerHTML  innerText
                                    domProps: {
                                        innerText: '倒序'
                                    },
                                    on: {
                                        // 绑定点击事件，使用箭头函数以免创建函数作用域
                                        click: () => {
                                            this.goods.reverse();
                                        }
                                    },
                                    // 自定义命令
                                    directives: [],
                                    // 其他属性
                                    key: 'btnReverse',
                                    ref: 'btnReverse'
                                }),

                                createElement('table', {
                                    // style 绑定样式 ，同 v-bind:style 的绑定方式
                                    style: {
                                        width: '400px',
                                        textAlign: 'left',
                                        lineHeight: '42px',
                                        border: '1px solid #eee',
                                        userSelect: 'none'

                                    }
                                }, [
                                    createElement('tr', [
                                        this.fields.map(field => createElement('th', field.prop))
                                    ]),

                                    this.goods.map(item => createElement('tr', {
                                            style: {
                                                color: item.isMarked ? '#ea4335' : ''
                                            }
                                        },
                                        this.fields.map(field => createElement('td', {style: {borderTop: '1px solid #eee'}}, [
                                            // 如果不是操作列，显示文本，否则显示按钮
                                            field.prop !== 'operate' ? createElement('span', item[field.prop]) : createElement('button', {
                                                class: ['btn', 'btn-text'],
                                                domProps: {
                                                    innerHTML: '<span>切换标记</span>'
                                                },
                                                on: {
                                                    click: () => {
                                                        item.isMarked = !item.isMarked;
                                                    }
                                                }
                                            })
                                        ]))
                                    ))

                                ])
                            ]);
                        }
                    })

                    let vm = new Vue({
                        el: '#app',
                        data() {
                            return {
                                fields: [
                                    {
                                        label:'名称',
                                        prop: 'name'
                                    },
                                    {
                                        label:'数量',
                                        prop: 'quantity'
                                    },
                                    {
                                        label:'价格',
                                        prop: 'price'
                                    },
                                    {
                                        label:'操作',
                                        prop: 'operate'
                                    }
                                ],

                                goods: [
                                    {
                                        name : '苹果',
                                        quantity: 200,
                                        price: 6.8,
                                        isMarked : false
                                    },

                                    {
                                        name : '西瓜',
                                        quantity: 50,
                                        price: 4.8,
                                        isMarked : false
                                    },

                                    {
                                        name : '榴莲',
                                        quantity: 0,
                                        price: 22.8,
                                        isMarked : false
                                    },
                                ]

                            }
                        }
                    })
                </script>
                </body>
                </html>

            template 和 render 选项均是用于增加JS代码以减少 HTML 代码的开发，这样做的好处有两个：
                1. 使开发者可以聚焦于JS代码的书写
                2. 更贴近于Vue的底层编译器
            相比于template，reendee函数充分地体现了JS的完全编程能力（脱离html和css代码的开发）

            借助于 babel-plugin-transform-vue-jsx插件，开发者亦可以使用JSX语法


            事件修饰符
            修饰符                         前缀               说明
            .passive                        &               移动端，限制事件永不调用 preventDefault()方法
            .capture                        !               当事件触发时，阻止事件捕获
            .once                           ~               事件被触发一次后即解除监听
            .capture.once/.once.capture     ~!              事件被触发一次后即解除监听并阻止事件捕获

            用法如下：
                on: {
                    '!click':() =? {}, // .capture
                    '~keyup':() => {}, // .once
                    '~!mouseover': () => {} // .capture.once
                }


            其他的一些事件修饰符，开发者可以使用原生JS编写。如下：

            部分事件修饰符与原生JS的对照表
            修饰符                 原生JS
            .stop                   event.stopPropagation()
            .prevent                event.preventDefault()
            .self                   if(event.target  != event.currentTarget) return
            .enter/.13              if(event.keyCode !== 13) return
            .ctrl                   if(!event.ctrlKey) return

            用法如下：
                on : {
                    keyup: function(event) {
                        //.self
                        if(event.target !== event.currentTarget) return
                        // .shift && .enter(.13)
                        if(!event.shiftKey || event.keyCode !== 13) return
                        // .stop
                        event.stopPropagation()
                        // .prevent
                        event.preventDefault()
                    }
                }

            在HTML中，任何内容都是节点，即使没有标签的文本也是节点，层层节点嵌套，形成一颗DOM树。
            在DOM中查询和更新节点是一件比较低效的工作，为此，Vue提供了renter函数和虚拟DOM，虚拟DOM将对真实的DOM发生的变化进行跟踪，
            以降低DOM查询的用时。

            与 document.createElement不同的是，render的createElement创建的并不是真是的DOM节点，而是虚拟节点 （Virtual Node，VNode），
            含有开发者描述的信息。由VNode组成的树形结构即 “虚拟节点”，Vue将通过虚拟DOM在页面上渲染出真实的DOM


            在组件树中，VNode必须保持其身份唯一，以便vue一一对应地对每个真实的DOM节点进行跟踪

        14.6.4 选项优先级
            优先级             高低（越往后，优先级越低）
            render              1
            template            2
            el                  3


    14.7 封装复用
        14.7.1 过滤器
            filters选项用于定义在当前组件或实例作用域中可用的过滤器，可在 双括号插值中添加在 JavaScript 表达式的尾部，以管道符号 “|” 与 表达式隔开，表达式的值将作为参数传入filter中，
            代码如下：
                <!DOCTYPE html>
                <html lang="en">
                <head>
                    <meta charset="UTF-8">
                    <title>过滤器-封装复用</title>
                </head>
                <body>
                <div id="app">
                    <h1>{{title}}</h1>
                    <h1>{{title | supplyTitle1}}</h1>
                    <h1>{{title | supplyTitle1 | supplyTitle2}}</h1>
                </div>

                <script src="https://cdn.jsdelivr.net/npm/vue@2.5.16/dist/vue.min.js"></script>
                <script>
                    let vm = new Vue({
                        el:'#app',
                        data() {
                            return {
                                title:'Test#%for#%Filter'
                            }
                        },
                        filters :{
                            supplyTitle1 (value) {
                                console.log("Supply Title 1");
                                return value.replace(/#/g,' ')
                            },
                            supplyTitle2 (value) {
                                console.log("Supply Title 2");
                                return value.replace(/%/g,' ')
                            }
                        }
                    })
                </script>
                </body>
                </html>

            当存在多个filter时，vue将从左向右执行过滤，并将上一次过滤的结果作为下一次的过滤的输入值。
            除在组件中定义filter之外，还允许在全局定义filter，全局filter的使用方法与选项filter一样，定义代码如下
                <!DOCTYPE html>
                <html lang="en">
                <head>
                    <meta charset="UTF-8">
                    <title>过滤器-封装复用</title>
                </head>
                <body>
                <div id="app">
                    <h1>{{ title }}</h1>
                    <h1>{{ title | supplyTitle1 }}</h1>
                    <h1>{{ title | supplyTitle1 | supplyTitle2 }}</h1>
                </div>

                <script src="https://cdn.jsdelivr.net/npm/vue@2.5.16/dist/vue.min.js"></script>
                <script>

                    Vue.filter('supplyTitle1', value => {
                            console.log("Supply Title 1");
                            return value.replace(/#/g, ' ')
                        }
                    )

                    Vue.filter('supplyTitle2', value => {
                            console.log("Supply Title 1");
                            return value.replace(/%/g, ' ')
                        }
                    )

                    let vm = new Vue({
                        el: '#app',
                        data() {
                            return {
                                title: 'Test#%for#%Filter'
                            }
                        }
                    })
                </script>
                </body>
                </html>

        14.7.2 自定义指令
            Vue允许使用一些自定义的指令。在组件或者实例中，这些自定义指令应该被声明在directives选项中，
            vue为自定义指令提供了如下几个钩子函数（均为可选）:
                bind: 指令与元素绑定时调用
                inserted: 指令绑定的元素被挂载到父元素上时调用。
                update: 指令所在VNode 更新时调用，可能发生在其子VNode更新之前。
                componentUpdated： 指令所在VNode及其子VNode全部更新后调用
                unbind: 指令与元素解绑时调用

            同时，钩子函数会被传入以下参数
                el: 指定所绑定的元素，用于操作DOM，
                binding: 包含指令相关属性的时候
                vnode ：虚拟节点
                oldVnode ：虚拟节点更新前的值，仅在 update和componentUpdated钩子函数中可用.
            binding包含以下属性:
                name ：指令名称
                value ：指令绑定的值，如在v-some=“2*2”中，绑定值为4
                oldValue ：指令值改变前的值，仅在update和componentUpdated钩子函数中可用
                expression ：字符串类型的指令表达式，  如在v-some=“2*2”中，值为 “2*2”
                arg ：传给指令的参数，如在 v-some:someValue中，值为“someValue”
                modifiers：修饰符对象，如在 v-some.upper中 值为 {upper:true}

            代码如下：
                <!DOCTYPE html>
                <html lang="en">
                <head>
                    <meta charset="UTF-8">
                    <title>过滤器-封装复用</title>
                </head>
                <body>
                <div id="app">
                    <h1 v-some.upper>{{ title }}</h1>
                    <h1 v-some.lower>{{ title }}</h1>
                    <h1 v-style="style">{{ title }}</h1>

                    <button @click="handleStyle">修改 v-style</button>
                </div>

                <script src="https://cdn.jsdelivr.net/npm/vue@2.5.16/dist/vue.min.js"></script>
                <script>

                    let vm = new Vue({
                        el: '#app',
                        data() {
                            return {
                                title: 'Test for Directive.',
                                style: {
                                    fontStyle: 'italic'
                                }
                            }
                        },
                        methods: {
                            handleStyle() {
                                this.$set(this.style, 'color', '#ababab')
                                this.$set(this.style, 'transform', 'rotateX(45deg)')
                            }
                        },

                        directives: {
                            style: { // 用于为节点绑定样式
                                bind(el, binding, vnode) {
                                    console.log("%c---------------------------bind参数：el，binding，vnode--------------------", 'font-size:18px;');
                                    console.log('%o\n\n%o\n\n%o', el, binding, vnode);
                                    let styles = binding.value;     // 获取指令绑定的值
                                    Object.keys(styles).forEach(key => el.style[key] = styles[key])
                                },
                                update(el, binding, vnode, oldVnode) {
                                    console.log("%c---------------------------update参数：el，binding，vnode，oldVnode--------------------", 'font-size:18px;');
                                    let styles = binding.value;     // 获取指令绑定的值
                                    Object.keys(styles).forEach(key => el.style[key] = styles[key])
                                }
                            },
                            // 在binding 和update 时触发相同行为，且 无需定义其他钩子函数
                            // 指令可以简写为以下形式
                            some (el,binding) {
                                let text = el.innerText;
                                let modifiers = binding.modifiers;
                                if(modifiers.upper) { // 如果带有upper后缀，则大写文本
                                    el.innerText = text.toUpperCase();
                                }
                                if (modifiers.lower) {
                                    el.innerText = text.toLowerCase();
                                }
                            }
                        }
                    })
                </script>
                </body>
                </html>

            同filter 一样，Vue也允许开发者定义全局指令，定义方式代码如下：
                <!DOCTYPE html>
                <html lang="en">
                <head>
                    <meta charset="UTF-8">
                    <title>过滤器-封装复用</title>
                </head>
                <body>
                <div id="app">
                    <h1 v-some.upper>{{ title }}</h1>
                    <h1 v-some.lower>{{ title }}</h1>
                    <h1 v-style="style">{{ title }}</h1>

                    <button @click="handleStyle">修改 v-style</button>
                </div>

                <script src="https://cdn.jsdelivr.net/npm/vue@2.5.16/dist/vue.min.js"></script>
                <script>
                    Vue.directive('style', {
                        bind: function (el, binding, vnode) {
                            console.log("%c---------------------------bind参数：el，binding，vnode--------------------", 'font-size:18px;');
                            console.log('%o\n\n%o\n\n%o', el, binding, vnode);
                            let styles = binding.value;     // 获取指令绑定的值
                            Object.keys(styles).forEach(key => el.style[key] = styles[key])
                        },
                        update: function (el, binding, vnode, oldVnode) {
                            console.log("%c---------------------------update参数：el，binding，vnode，oldVnode--------------------", 'font-size:18px;');
                            let styles = binding.value;     // 获取指令绑定的值
                            Object.keys(styles).forEach(key => el.style[key] = styles[key])
                        }
                    })

                    Vue.directive('some', function (el, binding) {
                        let text = el.innerText;
                        let modifiers = binding.modifiers;
                        if (modifiers.upper) { // 如果带有upper后缀，则大写文本
                            el.innerText = text.toUpperCase();
                        }
                        if (modifiers.lower) {
                            el.innerText = text.toLowerCase();
                        }
                    })

                    let vm = new Vue({
                        el: '#app',
                        data() {
                            return {
                                title: 'Test for Directive.',
                                style: {
                                    fontStyle: 'italic'
                                }
                            }
                        },
                        methods: {
                            handleStyle() {
                                this.$set(this.style, 'color', '#ababab')
                                this.$set(this.style, 'transform', 'rotateX(45deg)')
                            }
                        }
                    })
                </script>
                </body>
                </html>

        14.7.3 组件的注册
            components 选项 用于为组件注册从外部引入的组件，由于子组件并非在全局定义，因此不可以直接在父组件的作用域内使用。
            选项常见的应用场景有引入第三方库中的组件和自定义组件等
            代码如下：
                <!DOCTYPE html>
                <html lang="en">
                <head>
                    <meta charset="UTF-8">
                    <title>过滤器-封装复用</title>
                </head>
                <body>
                <div id="app">
                    <easy-title></easy-title>
                    <easy-wish></easy-wish>
                    <easy-motto></easy-motto>
                </div>

                <script src="https://cdn.jsdelivr.net/npm/vue@2.5.16/dist/vue.min.js"></script>
                <script>
                    let EasyTitle = {
                        name: 'EasyTitle',
                        template: '<h1>大器晚成</h1>'
                    }

                    let EasyWish = {
                        name: 'EasyWish',
                        template: '<p>白发渔樵隐身山，浮名穷利岂愿沾。</p>'
                    }

                    let EasyMotto = {
                        name: 'EasyMotto',
                        template: '<p>过一方水土，历一番人事，方知天地不仁，万物刍狗。</p>'
                    }


                    let vm = new Vue({
                        el: '#app',
                        components: {
                            EasyTitle, EasyMotto, EasyWish
                        }
                    })
                </script>
                </body>
                </html>



        14.7.4 混入的使用
            与 components选项相似，mixins（混入）选项也用于注册在外部封装好的代码，不过这些代码更加碎片化，并不如组件一样成体系，混入的目的在于灵活地分发组件中一些可复用的功能。
            mixins可以将一些封装好的选项混入另一个组件中。在混入过程中，如果没有发生冲突，则执行合并，如果发生冲突且用户没有指定解决策略，vue将采用默认策略

            混入冲突时的默认策略
            冲突选项                                合并策略                    冲突策略
            data                                    合并根节点数据             优先采用组件的数据
            mounted等钩子函数                        混合为数组                 全部调用且先调用mixin的钩子函数
            methods/components/directives等         混为同一个对象              优先采用组件的键值对
            watch                                   混合为数组                 全部调用且先调用mixin的watch 方法

            代码如下：
                <!DOCTYPE html>
                <html lang="en">
                <head>
                    <meta charset="UTF-8">
                    <title>混入-封装复用</title>
                    <style>
                        #app {
                            color: #2c3e50;
                            font-family: Roboto, sans-serif;
                        }

                        .label {
                            display: inline-block;
                            min-width: 160px;
                        }
                    </style>
                </head>
                <body>
                <div id="app">
                    <h1>{{ title }}</h1>
                    <p><strong class="label">Text:</strong>{{ text }}</p>
                    <p><strong class="label">Plus Text:</strong>{{ plusText }}</p>
                    <p><strong class="label">Upper Text::</strong>{{ text | supplyUpper }}</p>
                    <button @click="toggleText">切换文本</button>
                </div>

                <script src="https://cdn.jsdelivr.net/npm/vue@2.5.16/dist/vue.min.js"></script>
                <script>
                    // 强耦合，需要被混入组件的data根节点中包含text属性
                    let mixin = {
                        data() {
                            return {
                                title: 'Test for mixin'
                            }
                        },

                        mounted() {
                            console.log('mixin mounted')
                        },

                        methods: {
                            toggleText() {
                                console.log("============" + this.text);
                                // this 指向 vue 实例
                                this.text = 'mixin Text'
                            }
                        },
                        computed: {
                            plusText() {
                                // 此处需要创建函数作用域以使this指向vue实例
                                return '+ ' + this.text + ' +'
                            }
                        },

                        filters: {
                            // 选项过滤器
                            supplyUpper: value => value.toUpperCase()
                        },

                        watch: {
                            // 监听器
                            text(value) {
                                console.log('mixin text :' + value)
                            }
                        }
                    }
                    let vm = new Vue({
                        el: '#app',
                        mixins: [mixin],
                        data() {
                            return {
                                title: 'A Title',
                                text: 'which one?'
                            }
                        },
                        mounted() {
                            console.log('instance mounted')
                        },
                        methods: {
                            toggleText() {
                                this.text = 'instance text'
                            }
                        },
                        watch: {
                            text(value) {
                                console.log('instance text :' + value)
                            }
                        }
                    })
                </script>
                </body>
                </html>

            Vue 也允许开发者使用 Vue.mixin 定义全局 mixin，不过这将为所有组件和示例混入 mixin选项
                // 为自定义的选项 'myOption' 注入一个处理器。
                Vue.mixin({
                  created: function () {
                    var myOption = this.$options.myOption
                    if (myOption) {
                      console.log(myOption)
                    }
                  }
                })

                new Vue({
                  myOption: 'hello!'
                })

15. Vue内置组件
    15.1 组件服务
        15.1.1 动态组件
            动态切换页面部分区域的视图，使用内置组件 component

            component 接收一个名为 is 的属性，is 的值应为在父组件中注册过的组件名称，代码如下：
                <!DOCTYPE html>
                <html lang="en">
                <head>
                    <meta charset="UTF-8">
                    <title>动态组件-内置组件</title>
                    <style>
                        .tabs {
                            margin: 0;
                            padding: 0;
                            list-style: none;
                        }

                        .per-tab {
                            display: inline-block;
                            width: 120px;
                            line-height: 32px;
                            border-left: 1px solid #ccc;
                            border-top: 1px solid #ccc;
                        }

                        .per-tab:last-child {
                            border-right: 1px solid #ccc;
                        }

                        .tab-content {
                            height: 240px;
                            border: 1px solid #ccc;
                        }

                    </style>
                </head>
                <body>
                <div id="app">
                    <ul class="tabs">
                        <li class="per-tab" @click="toggleView('Home')">Home</li>
                        <li class="per-tab" @click="toggleView('About')">About</li>
                    </ul>

                    <div class="tab-content">
                        <component :is="view"></component>
                    </div>
                </div>

                <script src="https://cdn.jsdelivr.net/npm/vue@2.5.16/dist/vue.min.js"></script>
                <script>
                    let Home = {
                        // Home 组件
                        template: '<p style="color:#787878;">Hello Home!</p>'
                    }

                    let About = {
                        // About 组件
                        template: '<p>Hello About!</p>'
                    }

                    let vm = new Vue({
                        el: '#app',
                        components: {Home, About},
                        data() {
                            return {
                                view: 'Home'
                            }
                        },
                        methods: {
                            toggleView(view) {
                                this.view = view
                            }
                        }
                    })
                </script>
                </body>
                </html>

        15.1.2 使用插槽分发内容
            通过 props 选项，组件可以接收多态的数据。
            希望组件接收多态的DOM结构，实现的方法有很多，比如 使用 props 配合 v-html 等。
            不过 使用内置组件slot（插槽）分发内容，更加简单。
            在定义多个插槽时，可以使用name属性对其进行区分，如果没有指定 name 属性，则 Vue 会将所有的插槽内容置于默认插槽 default 中
            示例代码如下：
                <!DOCTYPE html>
                <html lang="en" xmlns="http://www.w3.org/1999/html">
                <head>
                    <meta charset="UTF-8">
                    <title>动态组件-内置组件</title>

                </head>
                <body>
                <div id="app">
                    <slot-test>
                        <p>使用插槽分发内容</p>
                        <h1 slot="header">插槽测试！</h1>
                        <p>在组件中，没有指定插槽名称的元素将被置于默认插槽中</p>
                        <p slot="none">指定到不存在的插槽中的内容将不会被显示</p>
                    </slot-test>
                </div>

                <script src="https://cdn.jsdelivr.net/npm/vue@2.5.16/dist/vue.min.js"></script>
                <script>
                    let slotTest = {
                        template: '<div>' +
                            '<slot name="header">相当与占位元素，因此这些文件也不会被渲染</slot>' +
                            '<slot></slot>' + // 默认插槽
                            '</div>'
                    }

                    let vm = new Vue({
                        el: '#app',
                        components: {slotTest}
                    })
                </script>
                </body>
                </html>


            Vue 还提供了作用域插槽 slot-scope (在Vue 2.5.0 以下版本为 scope ，只可用于 template 元素)，
            我们可以使用 slot-scope 获取子组件回传的数据，用来在父组件中执行多态的渲染或响应。

            为了使父组件中的 slot-scope 生效，我们还需要在子组件中将有关的数据绑定到插槽中。
            示例代码如下：
                <!DOCTYPE html>
                <html lang="en" xmlns="http://www.w3.org/1999/html">
                <head>
                    <meta charset="UTF-8">
                    <title>动态组件-内置组件</title>
                    <style>
                        .btn {
                            outline: none;
                            border: none;
                            cursor: pointer;
                            padding: 5px 12px;
                        }

                        .btn-text {
                            color: #409eff;
                            background-color: transparent;
                        }

                        .btn-text:hover {
                            color: #66b1ff;
                        }

                        .fly-table {
                            width: 400px;
                            text-align: left;
                            line-height: 42px;
                            border: 1px solid #eee;
                            user-select: none;
                        }
                    </style>
                </head>
                <body>
                <div id="app">
                    <h2>Fly Table Component</h2>
                    <button class="btn btn-text"
                            title="点击使数组倒序"
                            @click="handleReverse">
                        倒序
                    </button>

                    <fly-table
                            :fields="fields"
                            :goods="goods">

                        <!-- 租价标签包裹着的内容将被分发 -->
                        <!-- 思考下：是否可以在fly-table组件中直接书写这段代码？ -->
                        <template slot-scope="{row , col}">
                            <span v-if="col.prop !== 'operate'">
                                {{ row[col.prop] }}
                            </span>
                            <button class="btn btn-text" v-else @click="handleMarked(row)">
                                切换标记
                            </button>
                        </template>
                    </fly-table>
                </div>

                <script src="https://cdn.jsdelivr.net/npm/vue@2.5.16/dist/vue.min.js"></script>
                <script>
                    let flyTable = {
                        props: {
                            fields: {
                                type: Array,
                                default() {
                                    return []
                                }
                            },

                            goods: {
                                type: Array,
                                default() {
                                    return []
                                }
                            }
                        },
                        template: function () {
                            return '<table class="fly-table">\n' +
                                '<tr>\n' +
                                '   <th \n' +
                                'v-for="(col,cIndex) in fields"' +
                                ':key="cIndex">\n' +
                                '{{col.label}}' +
                                '</th>' +
                                '</tr>' +
                                '<tr \n' +
                                'v-for="(row,rIndex) in goods"\n' +
                                ':key="rIndex"\n' +
                                ':style="{color:row.isMarked ? \'#ea4335\' : \'\'}">\n' +
                                '<td \n' +
                                'style="border-top: 1px solid #eee"\n' +
                                'v-for="(col,cIndex) in fields"\n' +
                                ':key="cIndex">\n' +
                                // slot 应写在子组件中，用于接收父组件分发的内容
                                '<slot :row="row" :col="col"></slot>\n' +
                                '</td>' +
                                '</tr>' +
                                '</table>'
                        }()
                    }

                    let vm = new Vue({
                        el: '#app',
                        components: {flyTable},
                        data() {
                            return {
                                fields: [
                                    {label: '名称', prop: 'name'},
                                    {label: '数量', prop: 'quantity'},
                                    {label: '价格', prop: 'price'},
                                    {label: '操作', prop: 'operate'}
                                ],
                                goods: [
                                    {name: '苹果', quantity: 200, price: 6.8, isMarked: false},
                                    {name: '榴莲', quantity: 50, price: 4.8, isMarked: false},
                                    {name: '西瓜', quantity: 0, price: 22.8, isMarked: false},
                                ]
                            }
                        },
                        methods: {
                            handleReverse() {
                                this.goods.reverse();
                            },
                            handleMarked(row) {
                                row.isMarked = !row.isMarked;
                            }
                        }
                    })
                </script>
                </body>
                </html>

        15.1.3 组件的缓存
            keep-alive 是一个抽象组件，即它不渲染任何DOM元素，也不会出现在组件结构树中。可以使用它缓存一些非动态的组件实例（没有或不需要数据变化）,
            以保留组件状态或减少重新渲染的开销

            keep-alive 应出现在组件被移除之后需要再次挂载的地方，比如使用动态组件时：
                <keep-alive>
                    <component :is="view"></component>
                </keep-alive>

                或

                <keep-alive>
                    <one v-if="isOne"></one>
                    <two v-else></two>
                </keep-alive>
            它还可以接收 include 和 exclude 两个 props 属性：
                include 字符串或正则表达式。只有匹配的组件会被缓存。
                exclude 字符串或正则表达式。任何被匹配的组件将不会被缓存。
            当组件在 keep-alive 内被切换时，它的activated 和 deactivated 这两个生命周期钩子函数将会被执行。

    15.2 过渡效果
        15.2.1 单节点的过渡
            Vue 提供了标签为 transition 的内置组件，在下列情形中，我们可以给任何元素和组件添加进入 / 离开时的过渡动画：
                1. 元素或组件初始渲染时
                2. 元素或组件显示 / 隐藏时 （使用 v-if 或 v-show 进行条件渲染时）
                3. 元素或组件切换时
            Vue 允许用户使用 CSS 和 JS 两种方式来定义过渡效果。
            在使用 CSS 过渡时，我们需要预置符合 Vue 规则的带样式的类名，这些类名用于定义过渡不同阶段时的样式：
                v-enter : 定义进入过渡的开始状态。在元素被插入前生效，被插入后的下一桢移除。
                v-enter-active : 定义进入过渡生效时的状态。在整个进入过渡阶段中应用，在元素被插入之前生效，在过渡/ 动画完成之后移除。这个类可以用来定义进入过渡的过程时间，延迟和曲线函数等。
                v-enter-to : 定义进入过渡结束时的状态，在元素被插入后的下一桢生效（此时 v-enter被移除），在过渡/ 动画完成之后移除。
                v-leave ：定义离开过渡的开始状态。在离开过渡被触发时立刻生效，下一帧被移除
                v-leave-active ：定义离开过渡生效的状态。在整个离开过渡的阶段中应用，在离开过渡被触发时立刻生效，在过渡 / 动画完成之后移除。这个类可以被定义离开过渡的过程时间、延迟和曲线函数。
                v-leave-to ：定义离开过渡的结束状态。在离开过渡被触发之后下一桢生效（此时v-leave被移除），在过渡/动画完成之后移除。

            在实例中存在多个不同的动画效果时，我们可以使用自定义前缀替换 v-，比如使用 slide-enter 替换 v-enter， 不过这需要赋予 transition 元素的 name 属性。

            示例代码如下：
                <!DOCTYPE html>
                <html lang="en" xmlns="http://www.w3.org/1999/html">
                <head>
                    <meta charset="UTF-8">
                    <title>动态组件-内置组件</title>
                    <style>
                        /* 在此处声明过渡样式类，从一个状态过渡到另一个状态 */
                        .v-enter, .v-leave-to {
                            opacity: 0;
                        }

                        .v-enter-active, .v-leave-active {
                            transition-property: opacity; /* 过渡属性 */
                            transition-delay: 100ms; /* 延迟 */
                            transition-duration: 900ms; /* 过渡时长 */
                            transition-timing-function: linear; /* 贝赛尔曲线 （动画速度曲线）*/
                        }

                        .rotate-enter,
                        .rotate-leave-to {
                            transform: rotateY(90deg);
                        }

                        .rotate-enter-active,
                        .rotate-leave-active {
                            transform-origin: left;
                            transition: transform 1s linear;
                        }
                    </style>
                </head>
                <body>
                <div id="app">
                    <button @click="isHidden = !isHidden">{{ isHidden ? '显示' : '隐藏'}}</button>
                    <!-- 默认前缀的过渡 -->
                    <transition>
                        <p v-if="!isHidden">使用默认前缀的过渡</p>
                    </transition>
                    <!-- 自定义前缀的过渡， transtionName 为变量-->
                    <transition :name="transitionName">
                        <p v-if="!isHidden">使用 rotate 前缀的过渡</p>
                    </transition>
                </div>

                <script src="https://cdn.jsdelivr.net/npm/vue@2.5.16/dist/vue.min.js"></script>
                <script>
                    let vm = new Vue({
                        el: '#app',
                        data() {
                            return {
                                isHidden : true,
                                transitionName : 'rotate'
                            }
                        }
                    })
                </script>
                </body>
                </html>

            除了transition 之外，我们还可以使用CSS中的animation ，或者直接使用 第三方动画库 （如 Animate.css） 来实现过渡动画。
            由于这些动画库有着不同的类名规则，无法与Vue默认的类名规则配合使用，因此vue为其提供了兼容方案，允许用户自定义过的类名，
            这些类名的优先级将高于默认的类名
            我们可以使用以下特性来自定义过渡类名：
                enter-class
                enter-active-class
                enter-to-class
                leave-class
                leave-active-class
                leave-to-class

            示例代码：
                <!DOCTYPE html>
                <html lang="en" xmlns="http://www.w3.org/1999/html">
                <head>
                    <meta charset="UTF-8">
                    <title>动态组件-内置组件</title>
                    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.5.2/animate.min.css"/>
                    <style>
                        .inline-block {
                            display: inline-block;
                        }

                        .rotate-enter-active {
                            animation: selfRotateIn 1s;
                        }

                        .rotate-leave-active {
                            animation: selfRotateOut 1s;
                        }

                        @keyframes selfRotateIn {
                            0% {
                                opacity: 0;
                                transform: rotateZ(-180deg);
                            }
                            100% {
                                opacity: 1;
                                transform: rotateZ(0deg);
                            }
                        }

                        @keyframes selfRotateOut {
                            0% {
                                opacity: 1;
                                transform: rotateZ(0deg);
                            }
                            100% {
                                opacity: 0;
                                transform: rotateZ(-180deg);
                            }
                        }
                    </style>
                </head>
                <body>
                <div id="app">
                    <button @click="isHidden = !isHidden">{{ isHidden ? '显示' : '隐藏' }}</button>
                    <!-- 默认前缀的过渡 -->
                    <transition name="rotate">
                        <span class="inline-block" v-if="!isHidden">自定义的动画</span>
                    </transition>

                    <transition name="custom"
                        enter-active-class="animated rotateIn"
                        leave-active-class="animated rotateOut">
                        <span class="inline-block" v-if="!isHidden">使用 Animate.css 动画</span>
                    </transition>
                </div>

                <script src="https://cdn.jsdelivr.net/npm/vue@2.5.16/dist/vue.min.js"></script>
                <script>
                    let vm = new Vue({
                        el: '#app',
                        data() {
                            return {
                                isHidden: true
                            }
                        }
                    })
                </script>
                </body>
                </html>

            Animate.css 高版本 的动画库 有些类名规则做了修改.


            在开发中，使用进入过渡便可实现初始渲染时的过渡效果。除此之外，Vue提供了专门的初始渲染过渡，这需要在transition 元素上添加的 appear 属性，不过 appear 过渡只支持
            自定义类名的过渡和JS过渡，用法如下：
                <transition
                    appear
                    appear-class="custom-appear-class"
                    appear-to-class="custom-appear-to-class"
                    appear-active-class="custom-appear-active-class"
                >
                    <!-- ... -->
                </transition>

            Vue为了高效地更新元素，会采用 “就近复用” 的策略。因此当我们需要隐藏 / 显示 多个相邻的相同标签的元素时，
            并不一定所有的元素都会执行过渡，因为部分元素可能被复用了（被复用的元素不会进入 / 离开）。
            为了解决这个问题，我们需要赋予元素唯一key值，让vue对元素进行跟踪。

            反之，当元素的key值发生变化时，vue不会复用原有的元素，而将重建新的元素。根据这一特点，我们可以通过改变元素的key值来触发过渡动画，
            这常被用在元素切换时，示例代码如下：
                <!DOCTYPE html>
                <html lang="en" xmlns="http://www.w3.org/1999/html">
                <head>
                    <meta charset="UTF-8">
                    <title>动态组件-内置组件</title>
                    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.5.2/animate.min.css"/>
                    <style>
                        .v-enter,.v-leave-to {
                            opacity: 0;
                        }
                        .v-enter-active,.v-leave-active {
                            transition: opacity 1s;
                        }
                    </style>
                </head>
                <body>
                <div id="app">
                    <button @click="isMaster = !isMaster">切换身份</button>
                    <!-- 默认前缀的过渡 -->
                    <transition>

                        <p :key="isMaster ? 'master' : 'other'">{{isMaster ? '大家好！': '东家好！'}}</p>
                    </transition>

                </div>

                <script src="https://cdn.jsdelivr.net/npm/vue@2.5.16/dist/vue.min.js"></script>
                <script>
                    let vm = new Vue({
                        el: '#app',
                        data() {
                            return {
                                isMaster: true
                            }
                        }
                    })
                </script>
                </body>
                </html>

            代码中明明只有一个 p 标签，可为什么页面上会有渐出和渐入的两个元素？
            由于在元素切换时，旧的元素要被隐藏，新的元素（key值改变，该元素是新建的）要被显示，两者过渡都需要一定的时间内，且vue默认进入和离开同时发生，
            因此会出现两个元素同时存在的问题。
            为了解决这个问题，vue提供了过渡模式：
                1. in-out : 新元素先出现，之后旧元素隐藏
                2. out-in : 旧元素先隐藏，之后新元素出现

            用法如下：
                <transition mode="out-in">
                    <!-- 元素 -->
                </transition>



            示例代码如下：
                <!DOCTYPE html>
                <html lang="en" xmlns="http://www.w3.org/1999/html">
                <head>
                    <meta charset="UTF-8">
                    <title>动态组件-内置组件</title>

                </head>
                <body>
                <div id="app">
                    <button @click="isHidden = !isHidden">{{ isHidden ? '显示' : '隐藏' }}</button>
                    <!-- 默认前缀的过渡 -->
                    <transition
                            :before-enter="handleBeforeEnter"
                            :enter="handleEnter"
                            :after-enter="handleAfterEnter"
                            :enter-cancelled="handleEnterCancelled"
                            :before-leave="handleBeforeLeave"
                            :leave="handleLeave"
                            :after-leave="handleAfterLeave"
                            :leave-cancelled="handleLeaveCancelled"
                    >



                        <p :key="isMaster ? 'master' : 'other'">{{isMaster ? '大家好！': '东家好！'}}</p>
                    </transition>

                </div>

                <script src="https://cdn.jsdelivr.net/npm/vue@2.5.16/dist/vue.min.js"></script>
                <script>
                    let vm = new Vue({
                        el: '#app',
                        data() {
                            return {
                                isHidden: true
                            }
                        },
                        methods : {
                            // vue 提供了以下钩子函数，这些钩子函数也可以结合CSS过渡和动画使用
                            handleBeforeEnter(el) {},
                            handleEnter(el,done) {
                                // 当只用JS过渡时，在enter和leave总必须使用done可以回调

                                // 否则他们将被同步调用，过渡会立即完成
                                done()
                            },
                            handleAfterEnter(el) {},
                            handleEnterCancelled(el) {},
                            handleBeforeLeave(el) {},
                            handleLeave(el,done) {},
                            handleAfterLeave(el) {},
                            handleLeaveCancelled(el) {},
                        }
                    })
                </script>
                </body>
                </html>

        15.2.2 多节点的过渡
            使用 v-for列表渲染的元素，使用 transition 组件实现过渡动画并不可用，vue提供了transition-group组件用以实现列表过渡，
            不同于transition的是：
                transition-group : 将以真实元素呈现，默认为span ，也可以通过tag属性更换为其他元素。
                过渡模式不可用
                内部元素必须提供唯一的key属性（就近复用会导致部分过渡失败）

            就地复用：如果数据项的顺序被改变，Vue 将不会移动 DOM 元素来匹配数据项的顺序， 而是简单复用此处每个元素。
                "就地复用"的模式是高效的，但是只适用于不依赖子组件状态或临时 DOM 状态 (例如：表单输入值) 的列表渲染输出。

            示例代码如下：
                <!DOCTYPE html>
                <html lang="en" xmlns="http://www.w3.org/1999/html">
                <head>
                    <meta charset="UTF-8">
                    <title>多节点的过渡-内置组件</title>
                    <style>
                        .list-enter,.list-leave-to {
                            opacity: 0;
                            transform: translateY(30px);
                        }

                        .list-enter-active ,
                        .list-leave-active {
                            transition: all 1s linear;
                        }
                    </style>
                </head>
                <body>
                <div id="app">
                    <button @click="addNewItem()">添加元素</button>
                    <!-- 默认前缀的过渡 -->
                    <br >
                    <transition-group name="list" tag="ul">
                        <li
                            v-for="item in list" :key="item">
                            {{item}}
                        </li>
                    </transition-group>

                </div>

                <script src="https://cdn.jsdelivr.net/npm/vue@2.5.16/dist/vue.min.js"></script>
                <script>
                    let vm = new Vue({
                        el: '#app',
                        data() {
                            return {
                                list : [0,1,2,3,4,5,6,7,8,9]
                            }
                        },
                        methods : {
                            addNewItem () {
                                this.list.push(this.list.length);
                            }
                        }
                    })
                </script>
                </body>
                </html>

            除了用以实现进出动画之外，transition-group 还可以用于改变元素定位的动画，这需要用到 v-move 特性。
            v-mode 动画效果的定义方式与 v-enter、v-leave 等一致，它可以帮助我们平滑地移动列表元素的位置。我们体会以下，示例代码以下：
                <!DOCTYPE html>
                <html lang="en" xmlns="http://www.w3.org/1999/html">
                <head>
                    <meta charset="UTF-8">
                    <title>多节点的过渡-内置组件</title>
                    <style>
                        .list-move {
                            transition: transform 1s;
                        }
                    </style>
                </head>
                <body>
                <div id="app">
                    <button @click="orderByRandom()">随机顺序</button>
                    <!-- 默认前缀的过渡 -->
                    <br>
                    <transition-group name="list" tag="ul">
                        <li
                                v-for="item in list" :key="item">
                            {{ item }}
                        </li>
                    </transition-group>

                </div>

                <script src="https://cdn.jsdelivr.net/npm/vue@2.5.16/dist/vue.min.js"></script>
                <script>
                    let vm = new Vue({
                        el: '#app',
                        data() {
                            return {
                                list: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
                            }
                        },
                        methods: {
                            orderByRandom() {
                                let tmp = []; // 初始化新数组
                                for (let i = 0; i < this.list.length; i++) {
                                    let num = Math.floor(Math.random() * (this.list.length - 0.001))

                                    let index = tmp.indexOf(num);

                                    while (index !== -1) {
                                        num = Math.floor(Math.random() * (this.list.length - 0.001));
                                        index = tmp.indexOf(num);
                                    }
                                    tmp.push(num);
                                }

                                this.list = tmp;
                            }
                        }
                    })
                </script>
                </body>
                </html>

16. Vue 项目化
    16.1 快速构建项目
        1. 打开控制台 输入：
            cnpm install vue-cli -g
            安装脚手架工具 Vue CLI，尚未安装 cnpm 可以输入：
            npm install cnpm -g --registry=https://registry.npm.taobao.org
            用来安装国内淘宝镜像源的cnpm
            在命令执行结束后，输入：
            vue --version

        2. 第一步只需在安装 环境时，安装一次就可，无需重复安装。
            在项目所奥放置的文件夹目录下打开控制台，输入：
            vue init webpack sprog
            此为初始化项目
            注：sprog 为项目名称

        3. 在模板下载完成后，Vue CLI 将引导我们精选项目配置，
            3.1 首先 会提示输入 项目名称：
                Project name sprog
            3.2 第二，会提示输入 项目描述，回车即可：
                Project description (A Vue.js project)
            3.3 第三，提示输入 作者：
                Author xxx
            3.4 其次，点回车，若出现命令不动的情况，再次点回车
                若出现 Install vue-router? ，表示 询问是否安装 vue 路由，可选择是/否。若选择否，安装路由时，就需要手动安装。这里选择是。
                Install vue-router? y
            3.5 第五，会提示 是否使用ESLint 检查代码 ，可选择是/否。若选择否，安装路由时，就需要手动安装。这里选择是。
                Use ESLint to lint your code? y

            3.6 若选择了第五，会提示 如下：
                > Standard (https://github.com/standard/standard)
                  Airbnb (https://github.com/airbnb/javascript)
                  none (configure it yourself)
                默认直接回车即可，当然也可 上下移动光标，回车，因为这里有三个选项

            3.7. 第七，会提示 是否安装单元测试工具，按个人意愿即可：
                Set up unit tests (Y/n) n

            3.8. 第八，会提示 是否安装  e2e tests with Nightwatch? ，按个人意愿即可：
                Setup e2e tests with Nightwatch? n

            3.9. 第九，会提示 安装项目的工具：
                > Yes, use NPM
                  Yes, use Yarn
                  No, I will handle that myself

                上下移动光标，回车即可

                这里选择第一个。

            3.10. 之后等待其创建项目即可。安装成功会有以下提示：
                # Project initialization finished!
                # ========================

                To get started:

                  cd sprog
                  npm run dev

            3.11 安装依赖：
                cnpm install

            3.12 构建项目的开发版本，输入
                npm start

            3.13 打开另一个控制台，输入
                npm run build
                构建项目的生产版本


    16.2 项目的目录介绍

        名称                      说明
        build                    开发和生产版本的构建脚本
        config                   开发和生产版本的部分构建配置
        dist                     由npm run build生成，项目的生产版本；项目完成后，交付该文件即可
        src                      项目开发的关键资源目录和主要工作空间
            assets              文件夹用于存放图片、音频、视频等资源
            components          用于存放我们开发的单文件组件
            router/index.js     用于配置项目的前端路由（用到了Vue）
            App.vue             vue cli为我们默认创建的项目的跟组件
            main.js             是webpack的入口文件
        static                  静态资源 （如使用JS赋值图片src时，该图片资源应放在static下）
        .babelrc                babel的配置文件(babel，下一代JS的预编译器)
        .eslintignore           ESLint代码语法检测的配置文件（应忽略的语法格式）
        .eslintrc.js            ESLint代码语法检测的配置文件（应规范的语法格式）
        .gitigonre              应被git版本控制工具忽略的文件
        .index.html             应被webpack注入资源的模板html文件



        接下来，看些文件代码：
            App.vue
            <template>
              <div id="app">
                <img src="./assets/logo.png">
                <router-view/>
              </div>
            </template>

            <script>
            export default {
              name: 'App'
            }
            </script>

            <style>
            #app {
              font-family: 'Avenir', Helvetica, Arial, sans-serif;
              -webkit-font-smoothing: antialiased;
              -moz-osx-font-smoothing: grayscale;
              text-align: center;
              color: #2c3e50;
              margin-top: 60px;
            }
            </style>

        1. 这是一个单文件组件，包含 HTML JS和CSS三个部分。显然，VUe CLI采用关注点分离的开发方式，这种开发方式是的组件的内聚性很强，也更适合于组件化的开发
        2. script标签中的内容为 vue 组件，template 标签中的内容为组件的DOM结构；style标签中的内容为CSS样式 （在被赋予scoped属性后，样式表的作用域进行在当前的组件中）
        3. export 和 import 是 ECMAScript 6 语法中用于模块话管理的两个关键字，这里使用 export 导出 vue组件以供外部调用.

            main.js
            // The Vue build version to load with the `import` command
            // (runtime-only or standalone) has been set in webpack.base.conf with an alias.
            import Vue from 'vue'
            import App from './App'
            import router from './router'

            Vue.config.productionTip = false

            /* eslint-disable no-new */
            new Vue({
              el: '#app',
              router,
              components: { App },
              template: '<App/>'
            })
        1. 这里使用 import 导入全局的vue对象、App组件、Vue Router 的配置。之后，创建了一个Vue实例，并将App组件和router注册到实例中
        2. 注册 /* eslint-disable no-new */ 用于告诉eslint忽略此处对new关键字的检测

        在 main.js 中，实例的el选项绑定了 id 为 app 的 DOM元素。会是App组件中的div元素吗？显然，不可能的
        由于App组件是被注册在实例中的（作为实力的子组件），那么 App组件中的元素当然不肯作为实例的挂载元素，那么，实例最终是被挂载在index.html 中的div 元素上吗？
        答案其实也不全是，
            <!DOCTYPE html>
            <html>
              <head>
                <meta charset="utf-8">
                <meta name="viewport" content="width=device-width,initial-scale=1.0">
                <title>sprog</title>
              </head>
              <body>
                <div id="app"></div>
                <!-- built files will be auto injected -->
              </body>
            </html>

        Vue CLI会将所有编译整理好的资源路径注入到以 index.html 为模板的镜像中，被注入后的镜像即生产版本中的项目的入口文件，也就是dist文件目录下的index.html
        这里的元素才是实例最终挂载的地方。

    16.3 前端路由
        16.3.1 前端路由的简单实现
            广义上的前端路由是指前端根据URL来分发视图，现有两个核心操作：
                1. 需要监听浏览器地址的变化
                2. 需要动态加载视图

            这里分别使用 Vue 和原生的JS来模拟实现，并用Node.js 创建服务端文件，服务端文件app.js代码如下：
                const http = require('http') // http 模块
                const fs = require('fs') // 文件处理模块
                const hostName = '127.0.0.1'
                const post = 3000
                const server = http.createServer(function (req,res) { // 创建 http 服务
                  let content = fs.readFileSync('index.html') // 读取文件
                  res.writeHead(200,{
                    // 设置响应内容类型
                    'content-type': 'text/html;charset="utf-8"'
                  })

                  res.write(content) // 返回index.html文件内容
                  res.end()

                })

                server.listen(post,hostName,function () { // 启动服务监听
                  console.log(`Server is running here : http://${hostName}:${post}`)
                })

            下面来看一下使用Vue实现前端路由的代码（index.html）
                <!DOCTYPE html>
                <html lang="en">
                <head>
                    <meta charset="UTF-8">
                    <title>Title</title>
                </head>
                <body>
                <div id="app">
                    <ul>
                        <li>
                            <router-link to="/">Home</router-link>
                        </li>
                        <li>
                            <router-link to="/about">About</router-link>
                        </li>
                    </ul>
                    <router-view></router-view>
                </div>
                <script src="https://cdn.jsdelivr.net/npm/vue@2.5.16/dist/vue.min.js"></script>
                <script>
                    let Home = {
                        template: '<h1>This is Home!</h1>'
                    }

                    let About = {
                        template: '<h1>This is About!</h1>'
                    }

                    let routes = [
                        // 定义路由规则
                        {path: '/', component: Home},
                        {path: '/about', component: About}
                    ]

                    let RouterLink = {
                        props: ['to'],
                        template:'<a :href="to"><slot name="default"></slot></a>'
                    }


                    let RouterView = {
                        data() {
                            return {
                                url : window.location.pathname  // 获取浏览器地址
                            }
                        },
                        computed: {
                            ViewComponent() {
                                return routes.find(route => route.path === this.url).component
                            }
                        },
                        render(h) {
                            return h(this.ViewComponent)
                        }
                    }

                    /* eslint-disable */
                    let vm = new Vue({
                        el:'#app',
                        components: {
                            RouterLink,
                            RouterView
                        }
                    })
                </script>
                </body>
                </html>

            使用原生JS实现前端路由的代码如下：index.html
                <!DOCTYPE html>
                <html lang="en">
                <head>
                    <meta charset="UTF-8">
                    <title>Title</title>
                </head>
                <body>
                <div id="app">
                    <ul>
                        <li>
                            <a href="#/">Home</a>

                        </li>
                        <li>
                            <a href="#/about">About</a>
                        </li>
                    </ul>
                    <div id="view"></div>
                </div>
                <script>
                    let Home = '<h1>This is Home!</h1>';

                    let About = '<h1>This is About!</h1>';

                    let Router = function (el) { // 定义路由类
                        let view = document.getElementById(el);
                        let routes = [] // 路由规则列表
                        let load = function (route) { // 加载视图
                            route && (view.innerHTML = route.template)
                        }

                        let redirect = function () {
                            // 分发视图
                            let url = window.location.hash.slice(1) || '/'
                            for(let route of routes) {
                                url === route.url && load(route)
                            }
                        }

                        this.push = function (route) {
                            // 添加路由规则
                            routes.push(route)
                        }

                        window.addEventListener('load',redirect,false); // 页面加载时
                        window.addEventListener('hashchange',redirect,false); // url 变化时
                    }

                    let router = new Router('view'); // 实例化路由
                    router.push({
                        url : '/',
                        template : Home
                    })

                    router.push({
                        url : '/about',
                        template : About
                    })
                </script>
                </body>
                </html>

        16.3.2 Vue中的前端路由
            Vue Router 是 Vue.js 官方提供的路由管理器，它与vue.js 的核心深度集成，且随着Vue.js版本的更新而更新，致力于简化单页面应用构建

            1. 基础路由
                示例代码如下：
                    <script src="https://unpkg.com/vue/dist/vue.js"></script>
                    <script src="https://unpkg.com/vue-router/dist/vue-router.js"></script>
                    <div id="app">
                        <ul>
                            <li><router-link to="/">Home</router-link></li>
                            <li><router-link to="/about">About</router-link></li>
                        </ul>
                    </div>
                    <router-view></router-view>
                    <script>
                        let Home = {template:'<h1>This is Home!</h1>'}
                        let About = {template:'<h1>This is About!</h1>'}
                        let routes = [
                            {path:'/',component:Home}
                            {path:'/about',component:About}
                        ]

                        let router = new VueRouter({
                            routers
                        })

                        let app = new Vue({
                            router
                        }).mount('#app')
                    </script>

                RouterLink 和 RouterView 是 Vue Router提供的两个内置组件。RouterLink 默认会被渲染成为一个<a>标签，它的to属性
                属于指定跳转链接；RouterView将负责挂载路由匹配到的视图组件

            2. 动态路由
                示例代码如下：
                     <script src="https://unpkg.com/vue/dist/vue.js"></script>
                     <script src="https://unpkg.com/vue-router/dist/vue-router.js"></script>
                     <div id="app">
                        <ul>
                            <li><router-link to="/">Home</router-link></li>
                            <li @click="add"><router-link to="/about">About</router-link></li>
                        </ul>
                        <router-view></router-view>
                     </div>
                     <script>
                        let Home = {template:'<h1>This is Home!</h1>'}
                        let About = {
                            template:'div' +
                                     '<h1>This is About!</h1>' +
                                     '<p>num : {{$route.params.num}}</p>' +
                                     '</div>'
                        }
                        let routes = [
                            {path:'/',component:Home}
                            {path:'/about/:num',component:About}  // 1. 定义了参数 num  格式如 /:num
                        ]

                        let router = new VueRouter({
                            routes
                        })

                        let app = new Vue({
                            data() {
                                return {
                                    num : 0
                                }
                            },
                            methods:{
                                add() {
                                    this.num++
                                }
                            },
                            router
                        }).mount("#app")
                     </script>

                可以使用动态路由参数将匹配某种模式的所有路由映射到同一个组件 （RESTful）
                路径参数应用英文冒号“:”标记，但是在使用时应注意设计的规则是否合理，比如：
                    routers = [
                        {path:'/:any',component:Home}   // 可以匹配路径为 /about的路由，"about"将作为any的值
                    ]

                将会把所有路径都匹配到Home组件中。
                当动态路径被匹配时，我们可以在组件中使用 this.$route.params 来获取参数的值

            3. 嵌套路由
                示例代码如下：
                    <script src="https://unpkg.com/vue/dist/vue.js"></script>
                    <script src="https://unpkg.com/vue-router/dist/vue-router.js"></script>
                    <div id="app">
                        <ul>
                            <li><router-link to="/">Home</router-link></li>
                            <li>
                                <div>
                                    <router-link to="/">Home</router-link>
                                </div>
                                <ul>
                                    <li><router-link to="/about/author">About - Author</router-link></li>
                                    <li><router-link to="/about/email">About - Email</router-link></li>
                                </ul>
                            </li>
                        </ul>
                    </div>
                    <script>
                        let Home = {template:'<h1>This is Home!</h1>'}
                        let About = {
                            // About 组件
                            template : '<div>' +
                                        '<h1>This is About!</h1>' +
                                        '<router-view></router-view>' +  // 嵌套的动态视图区
                                        '</div>'
                        }
                        let Author = {template: '<p>Author : lonelydwwn</p>'}
                        let Email = {template: '<p>Email : lonelydwwn@163.com</p>'}
                        let routes = [
                            {path:'/',component:Home}
                            {
                                path:'/about',
                                component:About,
                                children : [
                                    {path:'author',component:Author}
                                    {path:'email',component:Email}
                                ]
                            }
                        ],
                        let router = new VueRouter({
                            routes
                        })

                        let app = new Vue({
                            router
                        }).mount("#app")
                    </script>

                嵌套路由可以实现在动态视图中嵌套动态视图
                多层的动态视图可以使用Vue的内置组件component来实现，不过使用component切换的视图会在页面刷新后回到初始状态。
                而使用路由哦分发的视图在页面刷新后会保持当前路径对应的视图，并在浏览器的history中留下记录。


            4. 编程式路由
                示例代码如下：
                    <script src="https://unpkg.com/vue/dist/vue.js"></script>
                    <script src="https://unpkg.com/vue-router/dist/vue-router.js"></script>
                    <div id="app">
                        <ul>
                            // 默认字符串为路径参数
                            <li @click="redirectByPath('/')"></li>
                            <li>
                                <!-- 指定参数为路径 -->
                                <div @click="redirectByPath('/about')">About</div>
                                <ul>
                                    <!-- 嵌套路由 -->
                                    <li @click="redirectByPath('/about/author')">Author</li>
                                    <!-- 嵌套路由 ，动态路由，当使用path时，params参数不生效-->
                                    <li @click="redirectByPath('/about/email',{email:'lonelydawn@163.com'})">About - Email</li>
                                    <!-- 嵌套路由 ，动态路由，可以直接将参数写入path -->
                                    <li @click="redirectByPath('/about/email/lonelydawn@163.com')">About - Email</li>
                                    <!-- 嵌套路由 ，动态路由，使用命名路由跳转视图 -->
                                    <li @click="redirectByName('Email',{email:'lonelydawn@163.com'})">About - Email</li>
                                </ul>
                            </li>
                        </ul>
                        <router-view></router-view>
                    </div>
                    <script>
                        let Home = {template:'<h1>This is Home!</h1>'}
                        let About = {
                            // About 组件
                            template : '<div>' +
                                        '<h1>This is About!</h1>' +
                                        '<router-view></router-view>' +  // 嵌套的动态视图区
                                        '</div>'
                        }
                        let Author = {template: '<p>Author : lonelydwwn</p>'}
                        let Email = {template: '<p>Email : lonelydwwn@163.com</p>'}

                        let routes = [
                            {path:'/',component:Home},
                            {
                                path: '/about',
                                component: About,
                                children:[
                                    {name:'Author',path:'author',component:Author},
                                    {name:'Email',path:'email/:email',component:Email}
                                ]
                            }
                        ]

                        let router = new VueRouter({
                            routes
                        })

                        let app = new Vue({
                            methods: {
                                redirectByPath (path,params) {
                                    this.$router.push({path,params})
                                },
                                redirectByName (name,params) {
                                    this.$router.push({name,params})
                                }

                            },
                            router
                        }).mount("#app")
                    </script>

                1. 这里并没有使用RouterLink组件，而是在JS中使用 router.push 方法跳转视图。
                2. 我们可以通过路由的patch跳转视图，还可以赋予路由name属性，然后通过name跳转视图
                3. 动态参数应放在params中，当使用path 中，params参数不生效，此时应将参数值直接写进path中
            5. 使用Vue CLI快速构建的项目中的router/index.js
                示例代码如下：
                    import Vue from 'vue'
                    import Router from 'vue-router'
                    import HelloWorld from '@/components/HelloWorld'

                    Vue.use(Router)

                    export default new Router({
                      routes: [
                        {
                          path: '/',
                          name: 'HelloWorld',
                          component: HelloWorld
                        }
                      ]
                    })
                1. 这里使用Vue.use 安装 Vue Router插件
                2. 这里使用export返回路由规则。默认只有当路径 ”/“ 时，渲染 HelloWorld组件。


        16.4. 状态管理
            16.4.1 对象引用
            16.4.2 状态管理器 Vuex
                Vuex 用于管理分散在Vue各个组件中的数据
                每一个Vuex应用的核心都是一个store（仓库），可以理解它是一个”非凡的全局对象“。与普通的全局对象不同的是，基于Vue数据与视图绑定的特点，当
                store中的状态发生变化时，与之绑定的视图也会被重新渲染。
                这是一个单向的过程，因为store中的状态不允许被直接修改。改变store中的状态的唯一途径就是显示地提交 （commit） mutation，这可以让我们方便地跟踪每一个状态的变化。

                Vuex中有5个重要的概念：State、Getter、Mutation、Action、Module。
                State 用于维护所有应用层的状态，并确保应用只有唯一的数据源（SSOT、Single Source of Truth）

                State 的用法如下：
                    new Vuex.Store({
                        state: {
                            count : 1
                        }
                    })
                在组件中，可以直接使用 $store.state.count （前提是 store 已被注册到实例中），也可以先用 mapState辅助函数将其映射下来，代码如下：
                    import {mapState} from 'vuex'
                    export default {
                        computed : {
                            ...mapState (['count']) // ... 是ES6中的对象展开运算符
                        }
                    }


                Getter 维护由 State 派生的一些状态，这些状态随着State状态的变化而变化。与计算属性一样，Getter 中的派生状态在计算之后会被缓存起来，
                当重复调用时，如果被以来的状态没有变化，那么Vuex不会重新计算派生状态的值，而是直接采用缓存值。

                Getter 的用法如下：
                    new Vuex.Store({
                        state : {
                            count : 1
                        },
                        getters : {
                            tenTimesCount (state) {
                                // Vuex 为其注入state对象
                                return state.count * 10
                            }
                        }
                    })

                在组件中，我们可以直接使用 $store.getters.tenTimesCount，也可以先用 mapGetters辅助哈数将其映射下来，代码如下：
                    import { mapGetters } from 'vuex'

                    export default {
                        computed : {
                            ...mapGetters(['tenTimesCount'])
                        }
                    }

                Mutation 提供修改 State 状态的方法
                Mutation 的用法如下：
                    new Vuex.Store({
                        state : {
                            count : 0
                        },

                        mutation : {
                            addCount(state,num) {
                                state.count += num || 1
                            }
                        }
                    })

                在组件中，可以直接使用 store.commit 来提交 mutation ，代码如下：

                    methods : {
                        addCount () {
                            this.$store.commit('addCount') // store 被注入到Vue实例中后可使用 this.$store
                        }
                    }

                也可以先用 mapMutation 辅助函数将其映射下来，代码如下：
                    import { mapState, mapMutation } from 'vuex'

                    export default {
                        computed : {
                            ...mapState(['count']) // ...ES6中的对象展开运算符
                        },

                        methods : {
                            ...mapMutations (['addCount']) ,
                            ...mapMutations ({ // 为mutation 赋别名，注意冲突，此方法不常用
                                    increaseCount : 'addCount'
                            })
                        }
                    }

                Action 类似 Mutation ，不同在于：
                    1. Action 不能直接修改状态，只能不通过提交 mutation 来修改
                    2. Action 可以包含异步操作

                Action 的用法如下：
                    new Vuex.Store({
                        state : {
                            count : 0
                        },

                        mutations : {
                            addCount (state,num) {
                                state.count += num || 1
                            }
                        },

                        actions : {
                            // context 具有 和 store 实例相同的属性和方法
                            // 可以通过 context 获取 state 和 getters 中的值，或者 提交 mutation 和分发其他的action
                            addCountAsync (context , num) {
                                setInterval (function () {
                                    if (context.state.count < 2000) {
                                        context.commit('addCount',num || 100)
                                    }
                                },  num || 100)
                            }
                        }
                    })

                在组件中，可以直接使用 store.dispatch 来分发action ，代码如下：
                    methods : {
                        addCountAsync (num) {
                            this.$store.dispatch('addCountAsync',num)
                        }
                    }
                或者使用 mapActions 辅助函数先将其映射下来，代码如下：
                    import { mapState, mapActions } from 'vuex'

                    export default {
                        computed : {
                            ...mapState(['count']) // ...ES6中的对象展开运算符
                        },

                        methods : {
                            ...mapActions (['addCountAsync']) ,
                            ...mapActions ({ // 为action 赋别名，注意冲突，此方法不常用
                                    increaseCountAsync : 'addCountAsync'
                            })
                        }
                    }

                由于使用单一状态树，当项目的状态非常多时，store对象就会变得十分臃肿。因此，Vuex允许我们将store分割成模块，每个模块拥有独立的State、Getter、Mutation 和 Action
                模块之中还可以嵌套模块，每一级都有着相同的结构。
                    Module 的用法如下：

                        // 定义模块
                        const counter = {
                            namespaced : true , // 定义为独立的命名空间
                            state : {
                                count : 0
                            },

                            getters : {
                                // 模块中，计算方法还会具有 rootState rootGetters 参数以获取根模块中的数据
                                tenTimesCount(state,getters,rootState,rootGetters) {
                                    console.log(state,getters,rootState,rootGetters);
                                    return state.count * 10
                                }
                            },

                            mutations : {
                                addCount(state,num) {
                                    state.count += num || 1
                                }
                            },

                            actions : {
                                // context 具有和 store实例相同的属性和方法
                                // 可以通过context获取state 和 getters中的值，获取提交 mutation ，分发 action
                                // 在模块中，context 还会具有 rootState 和 rootGetters 属性以获取根模块中的数据
                                addCountAsync (context,num) {
                                    setInterval (function () {
                                        if (context.state.count < 2000) {
                                            context.commit('addCount',num || 100)
                                        }
                                    },  num || 100)
                                }
                            }
                        }

                        // 创建仓库
                        new Vuex.Store({
                            modules : {
                                counter
                            }
                        })

                    在组件中，模块的使用方法如下：
                        import {mapState,mapGetters,mapMutations,mapActions} from 'vuex'
                        export default {
                            computed : {
                                ...mapState ('counter',['count'])
                                ...mapGetters ('counter',['tenTimesCount'])
                            },
                            methods : {
                                ...mapMutations ('counter',['addCount'])
                                ...mapAction ('counter',['addCountAsync'])
                            }
                        }

                    作为一个状态管理器，首先要拥有保管状态的容器 -- State，为了满足衍生数据和数据链的需求，从而有了Getter；为了可以”显式地“修改状态，所以需要Mutation
                    为可以可以”异步地“修改状态 （满足 Ajax 等异步数据交互），所以 需要Action；最后，如应用有成百上千个状态，放在一起会显得十分庞杂，所以分模块管理（Module）

        16.5 在项目中使用 Vuex
            在构建好的项目中，在命令行中输入：
                 npm/cnpm install vuex --save-dev

            在src目录下创建 store、store/index.js 、store/modules 、 store/modules/counter.js
                store                       Vuex仓库开发的工作目录
                store/index.js              仓库的输出文件
                store/modules               目录用于防止各个模块
                store/modules/counter.js    使用个加数模块

            counter.js 中的代码如下：
                export default {
                  namespaced: true, // 定义独立的命名空间
                  state: {
                    count: 0
                  },
                  getters: {
                    // 在模块中，计算方法还会具有 rootState rootGetters参数以获取根模块中的数据
                    tenTimesCount(state, getters, rootState, rootGetters) {
                      console.log(state, getters, rootState, rootGetters);
                      return state.count * 10;
                    }
                  },

                  mutations: {
                    addCount(state, num) {
                      state.count += num || 1
                    }
                  },
                  actions: {
                    // context 具有和 store 实例相同的属性和方法
                    // 可以通过context 获取state和getters 中的值，获取提交mutation，分发action
                    // 在模块中，context 还会具有rootState和rootGetters属性以获取根模块中的数据
                    addCountAsync(context, num) {
                      setInterval(function () {
                        if (context.state.count < 2000) {
                          context.commit('addCount', num || 100)
                        }
                      }, num || 100)
                    }
                  }
                }

            index.js 代码如下：
                import Vue from 'vue';
                import Vuex from 'vuex';
                import Counter from "./modules/counter"; // 引入加数模块

                Vue.use(Vuex) // 安装插件

                export default new Vuex.Store ({
                  modules : {
                    Counter
                  }
                })

            要在Vue实例中引入这个仓库，还需要修改两个文件，main.js 和 HelloWorld.vue
            其次，修改 main.js
                // The Vue build version to load with the `import` command
                // (runtime-only or standalone) has been set in webpack.base.conf with an alias.
                import Vue from 'vue'
                import App from './App'
                import router from './router'
                import store from './store'

                Vue.config.productionTip = false

                /* eslint-disable no-new */
                new Vue({
                  el: '#app',
                  router,
                  store,  // 注册store仓库
                  components: { App },
                  template: '<App/>'
                })

            修改 components/HelloWorld.vue

                <template>
                  <div class="hello">
                    <h2>count : {{count}}</h2>
                    <h2>ten times : {{tenTimesCount}}</h2>
                    <button @click="addCountAsync(50)">add Count</button>
                    <button @click="addCountCount(20)">add Count2</button>
                  </div>
                </template>

                <script>
                import {mapState,mapGetters,mapMutations,mapActions} from "vuex";

                export default {
                  name: 'HelloWorld',
                  computed: {
                    ...mapState('counter',['count']),
                    ...mapGetters('counter',['tenTimesCount'])
                  },
                  methods:{
                    ...mapMutations('counter',['addCount']),
                    ...mapActions('counter',['addCountAsync'])
                  }
                }
                </script>

                <!-- Add "scoped" attribute to limit CSS to this component only -->
                <style scoped>
                  h1 , h2 {
                    font-weight: normal;
                  }

                  ul {
                    list-style-type: none;
                    padding: 0;
                  }

                  li {
                    display: inline-block;
                    margin: 0 10px;
                  }

                  a {
                    color: #42b983;
                  }
                </style>




